*mbyte.txt*     For Vim version 6.1.  Last change: 2002 Feb 28
                                      最近更新：2004 Jan 13

                VIM REFERENCE MANUAL	  by Bram Moolenaar et al.
                <译者:yemao http://vimcdoc.sf.net>


Multi-byte support				*multibyte* *multi-byte*
						*Chinese* *Japanese* *Korean*
多字节支持                                      *多字节**多字节字*
                                                *汉语* *日语* *朝鲜语*
This is about editing text in languages which have many characters that can
not be represented using one byte (one octet).  Examples are Chinese, Japanese
and Korean.  Unicode is also covered here.
这是关于用需要多字节支持而不是单字节支持语言编辑文件的说明，多字节语言包含有汉语，
日语，朝鲜语，同时也包含Unicode.

For an introduction to the most common features, see |usr_45.txt| in the user
manual.
For changing the language of messages and menus see |mlang.txt|.

{not available when compiled without the +multi_byte feature}
了解更多一般特点的介绍，请参考用户手册|usr_45.txt|.
如何更改菜单语言和信息语言，请参考|mlang.txt|.
注意：如果编译时没有加入multi_byte参数，vim将不支持多字节。


1.  Getting started			|mbyte-first|
1.开始                                  |mbyte-first|
2.  Locale				|mbyte-locale|
2.本地化                                |mbyte-locale|
3.  Encoding				|mbyte-encoding|
3.编码                                  |mbyte-encoding|
4.  Using a terminal			|mbyte-terminal|
4.使用终端                              |mbyte-terminal|
5.  Fonts on X11			|mbyte-fonts-X11|
5.X11的字体                             |mbyte-fonts-X11|
6.  Fonts on MS-Windows			|mbyte-fonts-MSwin|
6.MS-Windows的字体                      |mbyte-fonts-MSwin|
7.  Input on X11			|mbyte-XIM|
7.在X11下输入                           |mbyte-XIM|
8.  Input on MS-Windows			|mbyte-IME|
8.在MS-Windows下输入                    |mbyte-IME|
9.  Input with a keymap			|mbyte-keymap|
9.用键盘输入                            |mbyte-keymap|
10. Using UTF-8				|mbyte-utf8|
10.使用UTF-8                            |mbyte-utf8|
11. Overview of options			|mbyte-options|
11.特点总述                             |mbyte-options|

==============================================================================
1. Getting started					*mbyte-first*

This is a summary of the multibyte features in Vim.  If you are lucky it works
as described and you can start using Vim without much trouble.  If something
doesn't work you will have to read the rest.  Don't be surprised if it takes
quite a bit of work and experimenting to make Vim use all the multi-byte
features.  Unfortunately, every system has its own way to deal with multibyte
languages and it is quite complicated.
1.开始                          *mbyte-first*
这是Vim多字节特点的总体介绍。幸运的话，你的vim没有多大的问题，一切运行正常，如果
不正常，请阅读以下内容。不要惊讶你花了很多时间，经过多次试验才使vim支持多字节，
因为不幸的是，每个系统都有一套自己处理多字节语言的方法，而且非常复杂。

COMPILING

If you already have a compiled Vim program, check if the |+multi_byte| feature
is included.  The |:version| command can be used for this.

If +multi_byte is not included, you should compile Vim with "big" features.
You can further tune what features are included.  See the INSTALL files in the
source directory.
编译
如果你有编译好的Vim，检查它是否包含|+multi_byte|特性，|:version|命令可以做到这一点。
如果不包含，你需要重新编译vim，同时加上“big”特性。你也可以查看还有哪些特性，具体
请查看源代码中的INSTALL.

LOCALE

First of all, you must make sure your current locale is set correctly.  If
your system has been installed to use the language, it probably works right
away.  If not, you can often make it work by setting the $LANG environment
variable in your shell: >

	setenv lang ja_JP.EUC
本地化
首先，确认当前的locale设置正确。如果系统安装的语言和你将使用的语言一致，它将会正常工
作。否则，你需要在shell里面设置$LNAG变量来使它正常工作：
        setenv lang ja_JP.EUC

Unfortunately, the name of the locale depends on your system.  Japanese might
also be called "ja_JP.EUCjp" or just "ja".  To see what is currently used: >

	:language

To change the locale inside Vim use: >

	:language ja_JP.EUC
很不幸，locale的名字取决于你的系统。Japanese也可能被叫做“ja_JP.EUCjp”或者
“ja”。查看当前的语言：>
        :language
修改vim所用的locale：
        :language ja_JP.EUC

Vim will give an error message if this doesn't work.  This is a good way to
experiment and find the locale name you want to use.  But it's always better
to set the locale in the shell, so that it is used right from the start.

See |mbyte-locale| for details.
如果设置的locale不能工作，vim将会给出错误信息。要找出当前使用的locale，这是一个好
办法。不过最好是在shell里面设置locale，那样，启动的时候就可以正常使用。
具体请看|mbyte-locale|。


ENCODING

If your locale works properly, Vim will try to set the 'encoding' option
accordingly.  If this doesn't work you can overrule its value: >

	:set encoding=utf-8

See |encoding-values| for a list of acceptable values.
编码
如果locale正常工作，vim随后将设置‘encoding’，如果不能使用，你可以重新
设置来取代它:>
        :set encoding=utf-8
|encoding-values|包含了可以使用的值。

The result is that all the text that is used inside Vim will be in this
encoding.  Not only the text in the buffers, but also in registers, variables,
etc.  This also means that changing the value of 'encoding' makes the existing
text invalid!  The text doesn't change, but it will be displayed wrong.

You can edit files in another encoding than what 'encoding' is set to.  Vim
will convert the file when you read it and convert it back when you write it.
See 'fileencoding', 'fileencodings' and |++enc|.
设置之后，正在用vim编辑的文件将使用这种编码。不仅仅是缓冲区的文件，寄存器，变量
都会使用这种编码。这也意味着‘encoding’的改变使文件改变，不过不是内容的变化，
而是不能正常显示。
你可以在另一种编码下编辑文件，vim在读文件的时候把它转变成另一种编码，按原来的编码
保存文件。具体请看‘fileencoding’‘fileencodings’和‘++enc’.


DISPLAY AND FONTS

If you are working in a terminal (emulator) you must make sure it accepts the
same encoding as which Vim is working with.  If this is not the case, you can
use the 'termencoding' option to make Vim convert text automatically.

For the GUI you must select fonts that work with the current 'encoding'.  This
is the difficult part.  It depends on the system you are using, the locale and
a few other things.  See the chapters on fonts: |mbyte-fonts-X11| for
X-Windows and |mbyte-fonts-MSwin| for MS-Windows.
字体和显示
如果使用终端，你必须确定终端可以使用vim所使用的编码。否则你必须修改‘termencoding’
使vim自动转化文件编码。
在GUI下，你必须选择在当前编码下可以使用的字体。这和终端有所不同。它和你用的系统，
locale和一些其它的东西有关。具体请看|mbyte-fonts-X11|和|mbyte-fonts-MSwin|.

For X11 you can set the 'guifontset' option to a list of fonts that together
cover the characters that are used.  Example for Korean: >

	:set guifontset=k12,r12
在X11下，你可以设置‘guifontset’,把要使用的字体写入列表。以朝鲜语为例：
        :set guifontset=k12,r12

Alternatively, you can set 'guifont' and 'guifontwide'.  'guifont' is used for
the single-width characters, 'guifontwide' for the double-width characters.
Thus the 'guifontwide' font must be exactly twice as wide as 'guifont'.
Example for UTF-8: >

	:set guifont=-misc-fixed-medium-r-normal-*-18-120-100-100-c-90-iso10646-1
	:set guifontwide=-misc-fixed-medium-r-normal-*-18-120-100-100-c-180-iso10646-1

You can also set 'guifont' alone, Vim will try to find a matching
'guifontwide' for you.
同时，你可以设置‘guifont’和‘guifontwide’。‘guifont’设置single-width字体，‘guifontwide’
来设置double-width字体。因此，‘guifontwide’字体的宽度是‘guifont’字体的二倍。
以UTF-8为例:>
        :set guifont=-misc-fixed-medium-r-normal-*-18-120-100-100-c-90-iso10646-1
        :set guifontwide=-misc-fixed-medium-r-normal-*-18-120-100-100-c-90-iso10646-1
你也可以只设置‘guifont’，wim将自动设置‘guifontwide’。

INPUT

There are several ways to enter multi-byte characters:
- For X11 XIM can be used.  See |XIM|.
- For MS-Windows IME can be used.  See |IME|.
- For all systems keymaps can be used.  See |mbyte-keymap|.

The options 'iminsert', 'imsearch' and 'imcmdline' can be used to chose
the different input medhods or disable them temporarily.
输入
现在有多种方法输入多字节字
-在X11下，XIM可以输入多字节字，具体请看|XIM|.
-在MS-Windows下，IME可以输入多字节，具体请看|IME|。
-键盘在所有的系统下都可以输入。具体请看|mbyte-keymap|。
设置‘iminsert’‘imsearch’‘imcmdline’可以选择不同的输入方法，也可以
临时禁用它们。

==============================================================================
2.  Locale						*mbyte-locale*

The easiest setup is when your whole system uses the locale you want to work
in.  But it's also possible to set the locale for one shell you are working
in, or just use a certain locale inside Vim.
 最简单的设置就是系统使用你想用的locale，不过你也可以设置你所使用的shell的locale，
或者在vim中使用一定的locale。


WHAT IS A LOCALE?					*locale*

There are many of languages in the world.  And there are different cultures
and environments at least as much as the number of languages.	A linguistic
environment corresponding to an area is called "locale".  This includes
information about the used language, the charset, collating order for sorting,
date format, currency format and so on.  For Vim only the language and charset
really matter.
世界上有很多种语言，而不同的文化和环境的数量至少有语言的种类那么多。一个地区对应
的语言环境就叫“locale”，它包括所使用的语言，文字，排序规则，时间格式，货币格式
等信息，vim只和语言和文字有关。

You can only use a locale if your system has support for it.  Some systems
have only a few locales, especially in the USA.  The language which you want
to use may not be on your system.  In that case you might be able to install
it as an extra package.  Check your system documentation for how to do that.

The location in which the locales are installed varies from system to system.
For example, "/usr/share/locale" or "/usr/lib/locale".  See your system's
setlocale() man page.
你只能使用系统支持的locale，有的系统的只有很少的locale，在美国特别如此。也许你
想使用的语言系统没有，这样你就需要把它当一个额外的包来安装，具体请按系统文档操作。
不同的系统安装locale的位置也不同，例如，“/usr/share/locale”或者“/usr/lib/locale”,
具体请看setlocale()的man文档。

Looking in these directories will show you the exact name of each locale.
Mostly upper/lowercase matters, thus "ja_JP.EUC" and "ja_jp.euc" are
different.  Some systems have a locale.alias file, which allows translation
from a short name like "nl" to the full name "nl_NL.ISO_8859-1".

Note that X-windows has its own locale stuff.  And unfortunately uses locale
names different from what is used elsewhere.  This is confusing!  For Vim it
matters what the setlocale() function uses, which is generally NOT the
X-windows stuff.  You might have to do some experiments to find out what
really works.
在这些目录里你可以看到每个locale的全称，它们也区别大小写，因此“ja_JP.EUC”和
“ja_jp.euc”不同。有的系统有一个locale.alias文件，它允许一个简称如“nl”和它的
全称“nl_NL.ISO_8859-1”转化。
注意X-windows有自己的locale设置，不幸的是它使用的locale名也和其它地方不同。
这非常混乱！vim使用setlocale()的设置，而它不是X-windows的stuff，也许你需要经过
多次测试来找出X-windows使用的locale。

						*locale-name*
The (simplified) format of |locale| name is:

	language
or	language_territory
or	language_territory.codeset
locale名的简单的格式是
        language
或者    language_territory
或者    language_territory.codeset

Territory means the country (or part of it), codeset means the |charset|.  For
example, the locale name "ja_JP.eucJP" means:
	ja	the language is Japanese
	JP	the country is Japan
	eucJP	the codeset is EUC-JP
Territory表示国家(或者它的一部份)，codeset表示文字。例如，“ja_JP.eucJP”表示
        ja      语言是Japanese
        JP      国家是Japan
        ecuJP   文字是EUC-JP
But it also could be "ja", "ja_JP.EUC", "ja_JP.ujis", etc.  And unfortunately,
the locale name for a specific language, territory and codeset is not unified
and depends on your system.
不过它也可以是“ja”，“ja_JP.EUC”，“ja_JP.ujis”等等，糟糕的是，locale名对
一个特定的语言，国家和文字是不统一的，它取决于你的系统。

Examples of locale name:
    charset	    language		  locale name ~
    GB2312	    Chinese (simplified)  zh_CN.EUC, zh_CN.GB2312
    Big5	    Chinese (traditional) zh_TW.BIG5, zh_TW.Big5
    CNS-11643	    Chinese (traditional) zh_TW
    EUC-JP	    Japanese		  ja, ja_JP.EUC, ja_JP.ujis, ja_JP.eucJP
    Shift_JIS	    Japanese		  ja_JP.SJIS, ja_JP.Shift_JIS
    EUC-KR	    Korean		  ko, ko_KR.EUC
例子如下：
    文字            语言                  locale名
    GB2312	    Chinese (simplified)  zh_CN.EUC, zh_CN.GB2312
    Big5	    Chinese (traditional) zh_TW.BIG5, zh_TW.Big5
    CNS-11643	    Chinese (traditional) zh_TW
    EUC-JP	    Japanese		  ja, ja_JP.EUC, ja_JP.ujis, ja_JP.eucJP
    Shift_JIS	    Japanese		  ja_JP.SJIS, ja_JP.Shift_JIS
    EUC-KR	    Korean		  ko, ko_KR.EUC

USING A LOCALE

To start using a locale for the whole system, see the documentation of your
system.  Mostly you need to set it in a configuration file in "/etc".
使整个系统使用一个locale，请看系统文档。大部分情况你需要在“/etc”下的配置
文件中设置它。

To use a locale in a shell, set the $LANG environment value.  When you want to
use Korean and the |locale| name is "ko", do this:

    sh:    export LANG=ko
    csh:   setenv LANG ko

You can put this in your ~/.profile or ~/.cshrc file to always use it.
在shell里使用一个locale，设置$LANG环境变量。你想使用韩语，locale名为“ko”，
    sh:    export LANG=ko
    csh:   setenv LANG ko
要经常使用它，把它们写进~/.profile或者~/.cshrc中。

To use a locale in Vim only, use the |:language| command: >

	:language ko

Put this in your ~/.vimrc file to use it always.
只在vim中使用一个locale，用language命令:>
        :language ko
把它写进~/.vimrc写进就可以经常使用。

Or specify $LANG when starting Vim:

   sh:    LANG=ko vim {vim-arguments}
   csh:	  env LANG=ko vim {vim-arguments}

You could make a small shell script for this.
或者在启动vim的时候设置$LANG:
   sh:    LANG=ko vim {vim-arguments}
   csh:   env LANG=ko vim {vim-arguments}

==============================================================================
3.  Encoding				*mbyte-encoding*

Vim uses the 'encoding' option to specify how characters identified and
encoded when they are used inside Vim.  This applies to all the places where
text is used, including buffers (files loaded into memory), registers and
variables.
Vim用‘encoding’来设置vim识别字符和编码的方法。这个设置对文本使用的地方都有
效，包括buffers(文件载入内存)，registers和variables。

							*charset* *codeset*
Charset is another name for encoding.  There are subtle differences, but these
don't matter when using Vim.  "codeset" is another similar name.

Each characters is encoded as one or more bytes.  When all characters are
encoded with one byte, we call this a single-byte encoding.  The most often
used one is called "latin1".  This limits the number of characters to 256.
Some of these are control characters, thus even fewer can be used for text.
Charset是encoding的另一种叫法，它们有一点很小的区别，但是vim与这个无关。“codeset”
是它的另一个别名。
每个字符都被encoded成一个或者两个byte。所有的字符都被编码成一个字节，我们就叫它为
single-byte编码。最常用的是“latin1”。它把可用的字符数限制为256，其中还有一部分
控制字符，这使得用于文本的字符数更少。

When some characters use two or more bytes, we call this a multi-byte
encoding.  This allows using much more than 256 characters, which is required
for most East Asian languages.

Most multi-byte encodings use one byte for the first 127 characters.  These
are equal to ASCII, which makes it easy to exchange plain-ASCII text, no
matter what language is used.  Thus you might see the right text even when the
encoding was set wrong.
当有的字符使用两个或更多字节，我们叫它multi-byte编码，它允许更多的字符，这符合
大多数东方国家的要求。
多数multi-byte编码使用开始的127个字符作为一个字节，这和ASCII相同，使得转化
plain-ASCII变得容易，不管你使用哪种语言，所以就算你的encoding设置错了，你也可以
看到正确的文本。

							*encoding-names*
Vim can use many different character encodings.  There are three major groups:

1   8bit	Single-byte encodings, 256 different characters.  Mostly used
		in USA and Europe.  Example: ISO-8859-1 (Latin1).  All
		characters occupy one screen cell only.
Vim可以使用多种不同的字符编码，主要有以下三种：
1   8bit        Single-byte编码，256个不同的字符。主要是美国和欧洲使用。例如：
                ISO-8859-1(Latin1)，所有的字符占一个screen cell。

2   2byte	Double-byte encodings, over 10000 different characters.
		Mostly used in Asian countries.  Example: euc-kr (Korean)
		The number of screen cells is equal to the number of bytes
		(except for euc-jp when the first byte is 0x8e).
2   2byte       Double-byte编码，超过10000个字符。主要是亚洲各国使用。例如：
                euc-kr(Korean)。所占的screen cell数和byte数相同。(euc-jp例外，它
                的第一个字节是0x8e)。

u   Unicode	Universal encoding, can replace all others.  ISO 10646.
		Millions of different characters.  Example: UTF-8.  The
		relation between bytes and screen cells is complex.
u   Unicode     Universal编码，可以取代其它的编码。如：ISO 10646.
                有几百万个字符。例如：UTF-8.bytes和screen cell的关系很复杂。

Other encodings cannot be used by Vim internally.  But files in other
encodings can be edited by using conversion, see 'fileencoding'.
Note that all encodings must use ASCII for the characters up to 128 (except
when compiled for EBCDIC).
其它的编码不能在Vim内部使用，以其它方式编码的文件需要转化才能用vim编辑，具体
请看‘fileencoding’。注意所有的编码都必须用ASCII把字符数变成128个(编译成EBCDIC除外)。

Supported 'encoding' values are:			*encoding-values*
支持的编码如下：
1   latin1	8-bit characters (ISO 8859-1)
1   iso-8859-n	ISO_8859 variant (n = 2 to 15)
1   koi8-r	Russian
1   koi8-u	Ukrainian
1   8bit-{name} any 8-bit encoding (Vim specific name)
1   cp{number}	MS-Windows: any installed single-byte codepage
2   cp932	Japanese (Windows only)
2   euc-jp	Japanese (Unix only)
2   sjis	Japanese (Unix only)
2   cp949	Korean (Unix and Windows)
2   euc-kr	Korean (Unix only)
2   cp936	simplified Chinese (Windows only)
2   euc-cn	simplified Chinese (Unix only)
2   cp950	traditional Chinese (on Unix alias for big5)
2   big5	traditional Chinese (on Windows alias for cp950)
2   euc-tw	traditional Chinese (Unix only)
2   2byte-{name} Unix: any double-byte encoding (Vim specific name)
2   cp{number}	MS-Windows: any installed double-byte codepage
u   utf-8	32 bit UTF-8 encoded Unicode (ISO/IEC 10646-1)
u   ucs-2	16 bit UCS-2 encoded Unicode (ISO/IEC 10646-1)
u   ucs-2le	like ucs-2, little endian
u   utf-16	ucs-2 extended with double-words for more characters
u   utf-16le	like utf-16, little endian
u   ucs-4	32 bit UCS-4 encoded Unicode (ISO/IEC 10646-1)
u   ucs-4le	like ucs-4, little endian

The {name} can be any encoding name that your system supports.  It is passed
to iconv() to convert between the encoding of the file and the current locale.
For MS-Windows "cp{number}" means using codepage {number}.
Examples: >
		:set encoding=8bit-cp1252
		:set encoding=2byte-cp932
{name}只能是系统支持的编码名，用iconv()把文件的编码方式变成当前的编码方式也包含在
其中。对MS-Windows来说，“cp{number}”意味着使用codepage{number}。
<
Several aliases can be used, they are translated to one of the names above.
An incomplete list:
也可以使用别名，以下是上面编码名的转化的不完全列表：

1   ansi	same as latin1 (obsolete, for backward compatibility)
2   japan	Japanese: on Unix "euc-jp", on MS-Windows cp932
2   korea	Korean: on Unix "euc-kr", on MS-Windows cp949
2   prc		simplified Chinese: on Unix "chinese", on MS-Windows cp936
2   taiwan	traditional Chinese: on Unix "euc-tw", on MS-Windows cp950
u   utf8	same as utf-8
u   unicode	same as ucs-2
u   ucs2be	same as ucs-2 (big endian)
u   ucs-2be	same as ucs-2 (big endian)
u   ucs-4be	same as ucs-4 (big endian)

For the UCS codes the byte order matters.  This is tricky, use UTF-8 whenever
you can.  The default is to use big-endian (most significant byte comes
first):
UCS按一定的规则编码，更灵活的，能使用UTF-8的地方尽量使用UTF-8，它默认使用big-endian
(优先使用最重要的)。
	    name	bytes		char ~
	    ucs-2	      11 22	    1122
	    ucs-2le	      22 11	    1122
	    ucs-4	11 22 33 44	11223344
	    ucs-4le	44 33 22 11	11223344

On MS-Windows systems you often want to use "ucs-2le", because it uses little
endian UCS-2.
在MS-Windows系统上你需要使用，它只使用了一点endian UCS-2。

There are a few encodings which are similar, but exactly the same.  Vim treats
them as if they were different encodings, so that conversion will be done when
needed.  You might want to use the similar name to avoid conversion or when
conversion is not possible:

	cp932, shift-jis, sjis
	cp936, euc-cn
有一些编码看起来相似，实际上它们是相同的。Vim把它们当不同的编码来处理，必要时
还会发生转化，当转化不必要或者需要避免时，你可以使用相近的编码名。

							*encoding-table*
Normally 'encoding' is equal to your current locale and 'termencoding' is
empty.  This means that your keyboard and display work with characters encoded
in your current locale, and Vim uses the same characters internally.
一般情况下，‘encoding’和当前的locale相同，‘termencoding’为空，这意味着
键盘和显示方式以当前locale编码字符，Vim内部也使用相同的字符。
You can make Vim use characters in a different encoding by setting the
'encoding' option to a different value.  Since the keyboard and display still
use the current locale, conversion needs to be done.  The 'termencoding' then
takes over the value of the current locale, so Vim converts between 'encoding'
and 'termencoding'.  Example: >
	:let &termencoding = &encoding
	:set encoding=utf-8
你可以通过设置‘encodng’以不同的值来使vim使用另一种编码的字符，但是键盘和显示方式
仍用当前的locale，这就需要转化。然后‘termencoding’使用当前locale值，Vim在‘encoding’
和‘termencoding’之间转化。例如：
        :let &termencoding = &encoding
        :set encoding=utf-8
However, not all combinations of values are possible.  The table below tells
you how each of the nine combinations works.  This is further restricted by
not all conversions being possible, iconv() being present, etc.  Since this
depends on the system used, no detailed list can be given.
尽管如此，并不是所有组合都可以转化。下面这个表告诉你9个组合如何转化，更严格的，
现在的iconv()便所有组合转化，而且，它取决于你的系统，这里不能给出具体的信息。
('tenc' is the short name for 'termencoding' and 'enc' short for 'encoding')
(‘tenc’是‘termencoding’的简写，‘enc’是‘encoding’的简写)

'tenc'	    'enc'	remark ~

 8bit	    8bit	Works.  When 'termencoding' is different from
			'encoding' typing and displaying may be wrong for some
			characters, Vim does NOT perform conversion (set
			'encoding' to "utf-8" to get this).
                        可以转化，当‘termencoding’和‘encoding’不同时，有些字符
                        的输入和显示会有问题，Vim不能转化(把‘encoding’设成utf-8
                        可以解决)。
 8bit      2byte	MS-Windows: works for all codepages installed on your
			system; you can only type 8bit characters;
			Other systems: does NOT work.
                        MS-Windows：系统上安装的所有codepages都可以转化，同时，你
                        只能输入8bit字符，在其它的系统上都不行。
 8bit	   Unicode	Works, but you can only type 8bit characters; in a
			terminal you can only see 8bit characters; the GUI can
			show all characters that the 'guifont' supports.
                        可以转化，但是你只能输入8bit字符，在终端下你只能看到8bit字符，
                        在GUI下可以看到‘guifont’支持的所有字符。
 2byte	    8bit	Works, but typing non-ASCII characters might
			be a problem.
                        可以转化，但是输入non-ASCII字符会有问题。
 2byte	   2byte	MS-Windows: works for all codepages installed on your
			system; typing characters might be a problem when
			locale is different from 'encoding'.
			Other systems: Only works when 'termencoding' is equal
			to 'encoding', you might as well leave it empty.
                        MS-Windows：支持系统安装的所有的codepages之间的转化，当locale
                        和‘encoding’不同的时输入会有问题。
                        在其它系统上，当‘termencoding’和‘encoding’相同或者为空
                        时可以转化。          
 2byte	   Unicode	works, Vim will translate typed characters.
                        可以转化，同时Vim还会转化输入的字符。
 Unicode    8bit	works (unusual)
                        可以转化(不平常的)
 Unicode    2byte	does NOT work
                        不能转化
 Unicode   Unicode	works very well (leaving 'termencoding' empty works
			the same way, because all Unicode is handled
			internally as UTF-8)
                        转化非常好(当‘termencoding’为空时也可以转化，因为Unicode内部
                        使用UTF-8)

CONVERSION						*charset-conversion*

Vim will automatically convert from one to another encoding in several places:
- When reading a file and 'fileencoding' is different from 'encoding'
- When writing a file and 'fileencoding' is different from 'encoding'
- When displaying characters and 'termencoding' is different from 'encoding'
- When reading input and 'termencoding' is different from 'encoding'
- When displaying messages and the encoding used for LC_MESSAGES differs from
  'encoding' (requires a gettext version that supports this).
- When reading a Vim script where |:scriptencoding| is different from
  'encoding'.
- When reading or writing a |viminfo| file.
Most of these require the |+iconv| feature.  Conversion for reading and
writing files may also be specified with the 'charconvert' option.
在有些地方，Vim可以自动把一种编码转化成另一种编码：
-读文件和‘fileencoding’和‘encoding’不同时
-写文件和‘fileencoding’和‘encoding’不同时
-显示字符和‘termencoding’和‘encoding’不同时
-读取输入和‘termencoding’和‘encoding’不同时
-显示信息和LC_MESSAGE使用的编码和‘encoding’不同时
-Vim脚本|:scriptencoding|和‘encoding’不同时
-读写一个|viminfo|文件时
以上很多都需要|+iconv|特性，读写的转化也许还需要特别指定‘chaconvert’。
Useful utilities for converting the charset:
    All:	    iconv
	GNU iconv can convert most encodings.  Unicode is used as the
	intermediate encoding, which allows conversion from and to all other
	encodings.  See http://www.gnu.org/directory/libiconv.html.
转化字符和一些有用的工具
    All:            iconv
       GNU iconv可以转化很多编码，Unicode作为中间编码，它可以转化成其它所有的
       编码。具体请看http://www.gnu.org/directory/libiconv.html

    Japanese:	    nkf
	Nkf is "Network Kanji code conversion Filter".  One of the most unique
	facility of nkf is the guess of the input Kanji code.  So, you don't
	need to know what the inputting file's |charset| is.  When convert to
	EUC-JP from ISO-2022-JP or Shift_JIS, simply do the following command
	in Vim:
	    :%!nkf -e
	Nkf can be found at:
	http://www.sfc.wide.ad.jp/~max/FreeBSD/ports/distfiles/nkf-1.62.tar.gz
        Japanese:       nkf
        Nkf是“Network Kanji code conversion Filter”的缩写，nkf最特别的地方是它可以
        猜测输入的Kanji的编码。所以，你不必知道输入文件的|charset|是什么。要从ISO-2202-JP
        或Shift_JIS转化成EUC-JP，在Vim里输入以下命令：
            :%!nkf -e 
        Nkf可以在下面地址找到:
        http://www.sfc.wide.ad.jp/~max/FreeBSD/ports/distfiles/nkf-1.62.tar.gz

    Chinese:	    hc
	Hc is "Hanzi Converter".  Hc convert a GB file to a Big5 file, or Big5
	file to GB file.  Hc can be found at:
	ftp://ftp.cuhk.hk/pub/chinese/ifcss/software/unix/convert/hc-30.tar.gz
    Chinese:        hc
        Hc是“Hanzi Converter”的简写，Hc把一个GB文件转化成Big5文件，或者把一个
        Big5文件转化成GB文件，可以在以下地址找到:
        ftp://ftp.cuhk.hk/pub/chinese/ifcss/software/unix/convert/hc-30.tar.gz
    Korean:	    hmconv
	Hmconv is Korean code conversion utility especially for E-mail. It can
	convert between EUC-KR and ISO-2022-KR.  Hmconv can be found at:
	ftp://ftp.kaist.ac.kr/pub/hangul/code/hmconv/hmconv1.0pl3
    Korean:         hmconv
        Hmconv是一套E-mail文字转化的工具，它可以在EUC-KR和ISO-2202-KR之间转化。
        Hmconv可以在以下地址找到:
        ftp://ftp.kaist.ac.kr/pub/hangul/code/hmconv/hmconv1.0pl3
    Multilingual:   lv
	Lv is a Powerful Multilingual File Viewer.  And it can be worked as
	|charset| converter.  Supported |charset|: ISO-2022-CN, ISO-2022-JP,
	ISO-2022-KR, EUC-CN, EUC-JP, EUC-KR, EUC-TW, UTF-7, UTF-8, ISO-8859
	series, Shift_JIS, Big5 and HZ. Lv can be found at:
	http://www.ff.iij4u.or.jp/~nrt/freeware/lv4493.tar.gz
    Multilingual:   lv
        Lv是一个强大的多语言文件查看器，它还可以作为|charset|转化器，支持的
        |charset|有:ISO-2202-CN,ISO-2202-JP,ISO-2202-KR,EUC-CN,EUC-JP,EUC-KR,
        EUC-TW,UTF-7,UTF-8,ISO-8859系列，Shift_JIS,Big5和HZ.Lv可以在以下地址
        找到:
        http://www.ff.iij4u.or.jp/~nrt/freeware/lv4493.tar.gz
==============================================================================
4. Using a terminal					*mbyte-terminal*

The GUI fully supports multi-byte characters.  It is also possible in a
terminal, if the terminal supports the same encoding that Vim uses.  Thus this
is less flexible.

For example, you can run Vim in a xterm with added multi-byte support and/or
|XIM|.  Examples are kterm (Kanji term) and hanterm (for Korean), Eterm
(Enlightened terminal) and rxvt.
GUI全面支持多突出字节字符，如果终端支持Vim使用的编码，终端也可以，但是它灵活性
不高。
举个例子，你可以在支持多字节或者|XIM|的xterm里使用Vim，如:kterm(Kanji term),
hanterm(Korean),Eterm(Enlightened terminal)和rxvt。

If your terminal does not support the right encoding, you can set the
'termencoding' option.  Vim will then convert the typed characters from
'termencoding' to 'encoding'.  And displayed text will be converted from
'encoding' to 'termencoding'.  If the encoding supported by the terminal
doesn't include all the characters that Vim uses, this leads to lost
characters.  This may mess up the display.  If you use a terminal that
supports Unicode, such as the xterm mentioned below, it should work just fine,
since nearly every character set can be converted to Unicode without loss of
information.
如果你的终端不支持正确的编码，可以通过设置‘termencoding’来解决。然后，Vim
把输入的字符从‘termencoding’转化成‘encoding’，把显示的字符从‘encoding’
转化成‘termencoding’。如果终端所支持的编码不包含Vim所使用的字符，这会导致
字符丢失，也会引起显示混乱。如果你的终端支持Unicode，如以上提到的xterm，这就会
工作正常，特别是现在从其它编码转化成Unicode时不会丢失信息。

UTF-8 IN XFREE86 XTERM					*UTF8-xterm*

This is a short explanation of how to use UTF-8 character encoding in the
xterm that comes with XFree86 by Thomas Dickey (text by Markus Kuhn).
下面是一个简短的怎样在xterm使用UTF-8的说明，它来自于XFree86团队的Thomas Dickey
(文本为Markus Kuhn所作)。
Get the latest xterm version which has now UTF-8 support:

	http://www.clark.net/pub/dickey/xterm/xterm.tar.gz
从以下地址获得最新的支持UTF-8的xterm:
        http://www.clark.net/pub/dickey/xterm/xterm.tar.gz
Compile it with "./configure --enable-wide-chars ; make"
同时带以下参数编译“./configure --enable-wide-chars;make”
Also get the ISO 10646-1 version of various fonts, which is available on

	http://www.cl.cam.ac.uk/~mgk25/download/ucs-fonts.tar.gz

and install the font as described in the README file.
同时从以下地址获得ISO 10646-1所支持的多种字体:
       http://www.cl.cam.ac.uk/~mgk25/download/ucs-fonts.tar.gz
Now start xterm with >
现在，用以下命令启动xterm
  xterm -u8 -fn -misc-fixed-medium-r-semicondensed--13-120-75-75-c-60-iso10646-1
or, for bigger character: >
要使用大字体，请用以下命令:
  xterm -u8 -fn -misc-fixed-medium-r-normal--15-140-75-75-c-90-iso10646-1

and you will have a working UTF-8 terminal emulator. Try both >

   cat utf-8-demo.txt
   vim utf-8-demo.txt
现在，你有一个支持UTF-8的模拟终端，用以下两种方法测试>
   cat utf-8-demo.txt
   vim utf-8-demo.txt
with the demo text that comes with ucs-fonts.tar.gz in order to see
whether there are any problems with UTF-8 in your xterm.

For Vim you may need to set 'encoding' to "utf-8".

示例文件来自于ucs-fonts.tar.gz，它的目的是测试你的xterm使用UTF-8是否有问题。
Vim还需在设置‘encoding’为“utf-8”。
==============================================================================
5.  Fonts on X11					*mbyte-fonts-X11*

Unfortunately, using fonts in X11 is complicated.  The name of a single-byte
font is a long string.  For multi-byte fonts we need several of these...

First of all, Vim only accepts fixed-width fonts for displaying text.  You
cannot use proportionally spaced fonts.  This excludes many of the available
(and nicer looking) fonts.  However, for menus and tooltips any font can be
used.
不幸的是，在X11下使用字体是非常复杂的。单字节字体的名称是一个长字符串，而多字节
字体需要多个。
首先，Vim显示文本只能使用固定宽度的字体，你不能使用相称空间的字体，包括许多可用的
字体(也许还很好看)。尽管如此，菜单和工具栏可以使用任何字体。
Note that Display and Input are independent.  It is possible to see your
language even though you have no input method for it.

You should get a default font for menus and tooltips that works, but it might
be ugly.  Read the following to find out how to select a better font.
注意，显示和输入是独立的，就算没有输入你所使用的语言的输入法，你也可以看到你所使用的
语言。
你可以使用使用默认的字体来设置菜单和工具栏，但可能非常丑陋，阅读以下内容，你可以学到怎样
选择一个较好的字体。

X LOGICAL FONT DESCRIPTION (XLFD)
							*XLFD*
XLFD is the X font name and contains the information about the font size,
charset, etc.  The name is in this format:

FOUNDRY-FAMILY-WEIGHT-SLANT-WIDTH-STYLE-PIXEL-POINT-X-Y-SPACE-AVE-CR-CE
XLFD是X所使用的字体的名称，它包含字体大小，编码等信息。格式如下:
FOUNDRY-FAMILY-WEIGHT-SLANT-WIDTH-STYLE-PIXEL-POINT-X-Y-SPACE-AVE-CR-CE
Each field means:

- FOUNDRY:  FOUNDRY field.  The company that created the font.
- FAMILY:   FAMILY_NAME field.  Basic font family name.  (helvetica, gothic,
	    times, etc)
- WEIGHT:   WEIGHT_NAME field.  How thick the letters are.  (light, medium,
	    bold, etc)
每个字段的意思是:
-FOUNDRY：FOUNDRY字段，编写字体的公司名称。
-FAMILY：FAAMILY_NAME字段，基本的字体族名称(helvetica,gothic,times等等)
-WEIGHT：WEIGHT_NAME字段，字母的粗细。(light,medium,bold等等)。
- SLANT:    SLANT field.
		r:  Roman (no slant)
		i:  Italic
		o:  Oblique
		ri: Reverse Italic
		ro: Reverse Oblique
		ot: Other
		number:	Scaled font
-SLANT：SLANT字段
                
- WIDTH:    SETWIDTH_NAME field.  Width of characters.  (normal, condensed,
	    narrow, double wide)
- STYLE:    ADD_STYLE_NAME field.  Extra info to describe font.  (Serif, Sans
	    Serif, Informal, Decorated, etc)
- PIXEL:    PIXEL_SIZE field.  Height, in pixels, of characters.
-WIDTH:     SETWIDTH_NAME字段，字符宽度(normal,condensed,narrow,double wide)
-STYLE：    ADD_STYLE_NAME字段，字体的额外信息。(Serif,Sans-Serif,Informal,Decorated等等)
-PIXEL：    PIXEL_SIZE字段，字体高度，以pixels计算。
- POINT:    POINT_SIZE field.  Ten times height of characters in points.
- X:	    RESOLUTION_X field.  X resolution (dots per inch).
- Y:	    RESOLUTION_Y field.  Y resolution (dots per inch).
-POINT：    POINT_SIZE字段，10倍字体的高度，以points计算。
-X:         RESOLUTION_X字段，X的位数(每英寸多少点)
-Y：        RESOLUTION_Y字段，Y的位数(每英寸多少点)
- SPACE:    SPACING field.
		p:  Proportional
		m:  Monospaced
		c:  CharCell
- AVE:	    AVERAGE_WIDTH field.  Ten times average width in pixels.
- CR:	    CHARSET_REGISTRY field.  The name of the charset group.
-SPACE：    SPACING字段
                p：比例
                m：单空格
                c：charcell
-AVE：      AVERAGE_WIDTH字段，10倍字体的宽度，以pixels计算
-CR：       CHARSET_REGISTRY字段。编码组的名称
- CE:	    CHARSET_ENCODING field.  The rest of the charset name.  For some
	    charsets, such as JIS X 0208, if this field is 0, code points has
	    the same value as GL, and GR if 1.
-CE：       CHARSET_ENCODING字段，编码的其它名称。对一些编码来讲，如JIS X 0208，如果这
            个字段为0,那么code points和GL有相同的值，为1的话，和GR有相同的值。
For example, in case of a 14 dots font corresponding to JIS X 0208, it is
written like:
    -misc-fixed-medium-r-normal--16-110-100-100-c-160-jisx0208.1990-0
举个例子，设置大小为14,对应JIS X 0208编码，可以写成以下格式

X FONTSET
						*fontset* *xfontset*
A single-byte charset is typically associated with one font.  For multi-byte
charsets a combination of fonts is often used.  This means that one group of
characters are used from one font and another group from another font (which
might be double wide).  This collection of fonts is called a fontset.

Which fonts are required in a fontset depends on the current locale.  X
windows maintains a table of which groups of characters are required for a
locale.  You have to specify all the fonts that a locale requires in the
'guifontset' option.
single-byte字符和一个字有关，对多字节来讲，字母的组合经常用到，这意味着一组
字使用了一种字体和另一种字体组的字体(也许是双宽度)，字体的集合就叫做fontset。
fontset里的字体依赖于你系统的locale，X windows维护着这个locale所需要的字体组
的表，你需要在guifontset里指定locale所需要的全部字体。

NOTE: The fontset always uses the current locale, even though 'encoding' may
be set to use a different charset.  In that situation you might want to use
'guifont' and 'guifontwide' instead of 'guifontset'.
注意：fontset经常使用当前的locale，即使‘encoding’已设置成另一种编码，在那种
情况下，你要设置‘guifont’和‘guifontwide’而不是‘guifontset’。
Example:
    |charset| language		    "groups of characters" ~
    GB2312    Chinese (simplified)  ISO-8859-1 and GB 2312
    Big5      Chinese (traditional) ISO-8859-1 and Big5
    CNS-11643 Chinese (traditional) ISO-8859-1, CNS 11643-1 and CNS 11643-2
    EUC-JP    Japanese		    JIS X 0201 and JIS X 0208
    EUC-KR    Korean		    ISO-8859-1 and KS C 5601 (KS X 1001)
例如：

You can search for fonts using the xlsfonts command.  For example, when you're
searching for a font for KS C 5601: >
    xlsfonts | grep ksc5601

This is complicated and confusing.  You might want to consult the X-Windows
documentation if there is something you don't understand.
你可以用xlsfonts来查找字体，例如，你需要找KS C 5601的一种字体:>
    xlsfonts | grep ksc5601
这个比较复杂，也令人迷惑，也许你需要阅读X-Windows的文档，它可以帮助你
理解你不懂的地方。
						*base_font_name_list*
When you have found the names of the fonts you want to use, you need to set
the 'guifontset' option.  You specify the list by concatenating the font names
and putting a comma in between them.

For example, when you use the ja_JP.eucJP locale, this requires JIS X 0201
and JIS X 0208.  You could supply a list of fonts that explicitly specifies
the charsets, like: >

 :set guifontset=-misc-fixed-medium-r-normal--14-130-75-75-c-140-jisx0208.1983-0,
	\-misc-fixed-medium-r-normal--14-130-75-75-c-70-jisx0201.1976-0
当你找到你所需要的字体以后，你就可以通过设置‘guifontset’来设置字体。要使用一系列的
字体，你可以用“，”把它们隔开，例如:>
 :set 
Alternatively, you can supply a base font name list that omits the charset
name, letting X-Windows select font characters required for the locale.  For
example: >

 :set guifontset=-misc-fixed-medium-r-normal--14-130-75-75-c-140,
	\-misc-fixed-medium-r-normal--14-130-75-75-c-70
可以选择的是，你可以设置一个基本的省略编码名的字体列表，让X-Windows从locale选择
所需要的字体，例如：>
 :set 
Alternatively, you can supply a single base font name that allows X-Windows to
select from all available fonts.  For example: >

 :set guifontset=-misc-fixed-medium-r-normal--14-*
你也可以提供一个基本的字体名让X-Windows选择系统可用的所有字体，例如：>
 :set
Alternatively, you can specify alias names.  See the fonts.alias file in the
fonts directory (e.g., /usr/X11R6/lib/X11/fonts/).  For example: >

 :set guifontset=k14,r14
<
同时，你也可以指定字体别名，请参考字体目录下的fonts.alias文件(例如,/usr/X11R6/lib/X11/fonts).
例如:>
 :set 
							*E253*
Note that in East Asian fonts, the standard character cell is square.  When
mixing a Latin font and an East Asian font, the East Asian font width should
be twice the Latin font width.

If 'guifontset' is not empty, the "font" argument of the |:highlight| command
is also interpreted as a fontset.  For example, you should use for
highlighting: >
	:hi Comment font=english_font,your_font
If you use a wrong "font" argument you will get an error message.
Also make sure that you set 'guifontset' before setting fonts for highlight
groups.
在东方字体中，正规的字符单元是正方形，当你混和一个Latin字和一个东亚字的时候，东亚字
的宽度应该是Latin字的两倍。
如果‘guifontset’不为空，|:highlight|命令的“font”参数也可以看成是fontset的解释器。
例如，你可以设置高亮显示:>
        :hi 
如果你使用了一个错误的“font”参数，你会收到错误信息。同样确定你是在设置
‘guifontset’之前设置高亮显示。

USING RESOURCE FILES

Instead of specifying 'guifontset', you can set X11 resources and Vim will
pick them up.  This is only for people who know how X resource files work.

For Motif and Athena insert these three lines in your $HOME/.Xdefaults file:

	Vim.font: |base_font_name_list|
	Vim*fontSet: |base_font_name_list|
	Vim*fontList: your_language_font
不设置‘guifontset’，你可以设置X11 resources，Vim会从它们中取值。这仅仅对
了解X resource的人有用。
如果你使用Motif和Athena，把以下三行插入$HOME/.Xdefaults文件:

    
Note: Vim.font is for text area.
      Vim*fontSet is for menu.
      Vim*fontList is for menu (for Motif GUI)
注意：Vim.font设置文本
      Vim*fontSet设置菜单
      Vim*fontList设置Moitf GUI的菜单
For example, when you are using Japanese and a 14 dots font, >

	Vim.font: -misc-fixed-medium-r-normal--14-*
	Vim*fontSet: -misc-fixed-medium-r-normal--14-*
	Vim*fontList: -misc-fixed-medium-r-normal--14-*
<
举个例子，你使用日语，14号字体
or: >

	Vim*font: k14,r14
	Vim*fontSet: k14,r14
	Vim*fontList: k14,r14
<
或者
To have them take effect immediately you will have to do >

	xrdb -merge ~/.Xdefaults

Otherwise you will have to stop and restart the X server before the changes
take effect.
要使它们立即生效，你可以这样做
        xrdb -merge ~/.Xdefaults
不然，你要关闭X之后重新启动X来使它们生效。

The GTK+ version of GUI Vim does not use .Xdefaults, use ~/.gtkrc instead.
The default mostly works OK.  But for the menus you might have to change
it.  Example: >

	style "default"
	{
		fontset="-*-*-medium-r-normal--14-*-*-*-c-*-*-*"
	}
	widget_class "*" style "default"
GTK+版的GUI Vim不使用.Xdefaults，它使用~/.gtkrc，大多数都可以正常工作。要更改菜单
字体，你可以如下设置:>

==============================================================================
6.  Fonts on MS-Windows				*mbyte-fonts-MSwin*

The simplest is to use the font dialog to select fonts and try them out.  You
can find this at the "Edit/Select Font..." menu.  Once you find a font name
that works well you can use this command to see its name: >

	:set guifont

Then add a command to your |gvimrc| file to set 'guifont': >

	:set guifont=courier_new:h12
最简单的方法就是用对话框来选择字体。你可以在菜单“Edit/Select Font...”中找到。
一旦你找到一个好用的字体，你可以使用以下命令来查看它的名字:>
        :set guifont
然后你可以在|gvimrc|中添加一个命令来设置‘guifont’:>

==============================================================================
7.  Input on X11				*mbyte-XIM*

X INPUT METHOD (XIM) BACKGROUND			*XIM* *xim* *x-input-method*

XIM is an international input module for X.  There are two kind of structures,
Xlib unit type and |IM-server| (Input-Method server) type.  |IM-server| type
is suitable for complex input, such as CJK.

- IM-server
							*IM-server*
  In |IM-server| type input structures, the input event is handled by either
  of the two ways: FrontEnd system and BackEnd system.  In the FrontEnd
  system, input events are snatched by the |IM-server| first, then |IM-server|
  give the application the result of input.  On the other hand, the BackEnd
  system works reverse order.  MS Windows adopt BackEnd system.  In X, most of
  |IM-server|s adopt FrontEnd system.  The demerit of BackEnd system is the
  large overhead in communication, but it provides safe synchronization with
  no restrictions on applications.

  For example, there are xwnmo and kinput2 Japanese |IM-server|, both are
  FrontEnd system.  Xwnmo is distributed with Wnn (see below), kinput2 can be
  found at: ftp://ftp.sra.co.jp/pub/x11/kinput2/

  For Chinese, there's a great XIM server named "xcin", you can input both
  Traditional and Simplified Chinese characters.  And it can accept other
  locale if you make a correct input table.  Xcin can be found at:
  http://xcin.linux.org.tw/

- Conversion Server
							*conversion-server*
  Some system needs additional server: conversion server.  Most of Japanese
  |IM-server|s need it, Kana-Kanji conversion server.  For Chinese inputting,
  it depends on the method of inputting, in some methods, PinYin or ZhuYin to
  HanZi conversion server is needed.  For Korean inputting, if you want to
  input Hanja, Hangul-Hanja conversion server is needed.

  For example, the Japanese inputting process is divided into 2 steps.  First
  we pre-input Hira-gana, second Kana-Kanji conversion.  There are so many
  Kanji characters (6349 Kanji characters are defined in JIS X 0208) and the
  number of Hira-gana characters are 76.  So, first, we pre-input text as
  pronounced in Hira-gana, second, we convert Hira-gana to Kanji or Kata-Kana,
  if needed.  There are some Kana-Kanji conversion server: jserver
  (distributed with Wnn, see below) and canna. Canna can be found at:
  ftp://ftp.nec.co.jp/pub/Canna/

There is a good input system: Wnn4.2.  Wnn 4.2 contains,
    xwnmo (|IM-server|)
    jserver (Japanese Kana-Kanji conversion server)
    cserver (Chinese PinYin or ZhuYin to simplified HanZi conversion server)
    tserver (Chinese PinYin or ZhuYin to traditional HanZi conversion server)
    kserver (Hangul-Hanja conversion server)
Wnn 4.2 can be found at:
    ftp://ftp.FreeBSD.ORG/pub/FreeBSD/ports/distfiles/Wnn4.2.tar.gz


- Input Style
							*xim-input-style*
  When inputting CJK, there are four areas:
      1. The area to display of the input while it is being composed
      2. The area to display the currently active input mode.
      3. The area to display the next candidate for the selection.
      4. The area to display other tools.

  The third area is needed when converting.  For example, in Japanese
  inputting, multiple Kanji characters could have the same pronunciation, so
  a sequence of Hira-gana characters could map to a distinct sequence of Kanji
  characters.

  The first and second areas are defined in international input of X with the
  names of "Preedit Area", "Status Area" respectively.  The third and fourth
  areas are not defined and are left to be managed by the |IM-server|.  In the
  international input, four input styles have been defined using combinations
  of Preedit Area and Status Area: |OnTheSpot|, |OffTheSpot|, |OverTheSpot|
  and |Root|.

  Currently, GUI Vim support three style, |OverTheSpot|, |OffTheSpot| and
  |Root|.

*.  on-the-spot						*OnTheSpot*
    Preedit Area and Status Area are performed by the client application in
    the area of application.  The client application is directed by the
    |IM-server| to display all pre-edit data at the location of text
    insertion. The client registers callbacks invoked by the input method
    during pre-editing.
*.  over-the-spot					*OverTheSpot*
    Status Area is created in a fixed position within the area of application,
    in case of Vim, the position is the additional status line.  Preedit Area
    is made at present input position of application.  The input method
    displays pre-edit data in a window which it brings up directly over the
    text insertion position.
*.  off-the-spot					*OffTheSpot*
    Preedit Area and Status Area are performed in the area of application, in
    case of Vim, the area is additional status line.  The client application
    provides display windows for the pre-edit data to the input method which
    displays into them directly.
*.  root-window						*Root*
    Preedit Area and Status Area are outside of the application.  The input
    method displays all pre-edit data in a separate area of the screen in a
    window specific to the input method.


USING XIM			*multibyte-input* *E284* *E286* *E287* *E288*
				*E285* *E291* *E292* *E290* *ez4* *E289*

Note that Display and Input are independent.  It is possible to see your
language even though you have no input method for it.  But when your Display
method doesn't match your Input method, the text will be displayed wrong.

	Note: You can not use IM unless you specify 'guifontset'.
	      Therefore, Latin users, you have to also use 'guifontset'
	      if you use IM.

To input your language you should run the |IM-server| which supports your
language and |conversion-server| if needed.

The next 3 lines should be put in your ~/.Xdefaults file.  They are common for
all X applications which uses |XIM|.  If you already use |XIM|, you can skip
this. >

	*international: True
	*.inputMethod: your_input_server_name
	*.preeditType: your_input_style
<
input_server_name	is your |IM-server| name (check your |IM-server|
			manual).
your_input_style	is one of |OverTheSpot|, |OffTheSpot|, |Root|.  See
			also |xim-input-style|.

*international may not necessary if you use X11R6.
*.inputMethod and *.preeditType are optional if you use X11R6.

For example, when you are using kinput2 as |IM-server|, >

	*international: True
	*.inputMethod: kinput2
	*.preeditType: OverTheSpot
<
When using |OverTheSpot|, GUI Vim always connects to the IM Server even in
Normal mode, so you can input your language with commands like "f" and "r".
But when using one of the other two methods, GUI Vim connects to the IM Server
only if it is not in Normal mode.

If your IM Server does not support |OverTheSpot|, and if you want to use your
language with some Normal mode command like "f" or "r", then you should use a
localized xterm  or an xterm which supports |XIM|

If needed, you can set the XMODIFIERS environment variable:

	sh:  export XMODIFIERS="@im=input_server_name"
	csh: setenv XMODIFIERS "@im=input_server_name"

For example, when you are using kinput2 as |IM-server| and sh, >

	export XMODIFIERS="@im=kinput2"
<

FULLY CONTROLED XIM

You can fully control XIM, like with IME of MS-Windows (see |multibyte-ime|).
This is currently only available for the GTK GUI.

Before using fully controled XIM, one setting is required.  Set the
'imactivatekey' option to the key that is used for the activation of the input
method.  For example, when you are using kinput2 + canna as IM Server, the
activation key is probably Shift+Space: >

	:set imactivatekey=S-space

See 'imactivatekey' for the format.

==============================================================================
8.  Input on MS-Windows					*mbyte-IME*

(Windows IME support)				*multibyte-ime* *IME*

{only works Windows GUI and compiled with the |+multi_byte_ime| feature}

To input multibyte characters on Windows, you have to use Input Method Editor
(IME).  In process of your editing text, you must switch status (on/off) of
IME many many many times.  Because IME with status on is hooking all of your
key inputs, you cannot input 'j', 'k', or almost all of keys to Vim directly.

This |+multi_byte_ime| feature help this.  It reduce times of switch status of
IME manually.  In normal mode, there are almost no need working IME, even
editing multibyte text.  So exiting insert mode with ESC, Vim memorize last
status of IME and force turn off IME.  When re-enter insert mode, Vim revert
IME status to that momorized automatically.

This works on not only insert-normal mode, but also search-command input and
replace mode.

Cursor color when IME or XIM is on				*CursorIM*
    There is a little cute feature for IME.  Cursor can indicate status of IME
    by changing its color.  Usually status of IME was indicated by little icon
    at a corner of desktop (or taskbar).  It is not easy to verify status of
    IME.  But this feature help this.
    This works in the same way when using XIM.

    You can select cursor color when status is on by using highlight group
    CursorIM.  For example, add these lines to your _gvimrc: >

	if has('multi_byte_ime')
	    highlight Cursor guibg=Green guifg=NONE
	    highlight CursorIM guibg=Purple guifg=NONE
	endif
<
    Cursor color with off IME is green.  And purple cursor indicates that
    status is on.

WHAT IS IME
    IME is a part of East asian version Windows.  That helps you to input
    multibyte character.  English and other language version Windows does not
    have any IME.  (Also there are no need usually.) But there is one that
    called Microsoft Global IME.  Global IME is a part of Internet Exproler
    4.0 or above.  You can get more information about Global IME, at below
    URL.

WHAT IS GLOBAL IME					*global-ime*
    Global IME makes capability to input Chinese, Japanese, and Korean text
    into Vim buffer on any language version of Windows 98, Windows 95, and
    Windows NT 4.0.  Please see below URL for detail of Global IME.  You can
    also find various language version of Global IME at same place.

    - Global IME detailed information.
	http://www.microsoft.com/windows/ie/features/ime.asp

    - Active Input Method Manager (Global IME)
	http://msdn.microsoft.com/workshop/misc/AIMM/aimm.asp

    Support Global IME is a experimental feature.

NOTE: For IME to work you must make sure in the "Language settings for the
system" the default locale is set to your language.  The exact location of
this depends on the version of Windows you use.

==============================================================================
9. Input with a keymap					*mbyte-keymap*

When the keyboard doesn't produce the characters you want to enter in your
text, you can use the 'keymap' option.  This will translate one or more
(English) characters to another (non-English) character.  This only happens
when typing text, not when typing Vim commands.  This avoids having to switch
between two keyboard settings.

The value of the 'keymap' option specifies a keymap file to use.  The name of
this file is one of these two:

	keymap/{keymap}_{encoding}.vim
	keymap/{keymap}.vim

Here {keymap} is the value of the 'keymap' option and {encoding} of the
'encoding' option.  The file name with the {encoding} included is tried first.

'runtimepath' is used to find these files.  To see an overview of all
available keymap files, use this: >
	:echo globpath(&rtp, "keymap/*.vim")

In Insert and Command-line mode you can use CTRL-^ to toggle between using the
keyboard map or not. |i_CTRL-^| |c_CTRL-^|
This flag is remembered for Insert mode with the 'iminsert' option.  When
leaving and entering Insert mode the previous value is used.  The same value
is also used for commands that take a single character argument, like |f| and
|r|.
For Command-line mode the flag is NOT remembered.  You are expected to type an
Ex command first, which is ASCII.
For typing search patterns the 'imsearch' option is used.  It can be set to
use the same value as for 'iminsert'.

It is possible to give the GUI cursor another color when the language mappings
are being used.  This is disabled by default, to avoid that the cursor becomes
invisible when you use a non-standard background color.  Here is an example to
use a brightly colored cursor: >
	:highlight Cursor guifg=NONE guibg=Green
	:highlight lCursor guifg=NONE guibg=Cyan
<
			*keymap-file-format* *:loadk* *:loadkeymap* *E105*
The keymap file looks something like this: >

	" Maintainer:	name <email@address>
	" Last Changed:	2001 Jan 1

	let b:keymap_name = "short"

	loadkeymap
	a	A
	b	B	comment

The lines starting with a " are comments and will be ignored.  Blank lines are
also ignored.  The lines with the mappings may have a comment after the useful
text.

The "b:keymap_name" can be set to a short name, which will be shown in the
status line.  The idea is that this takes less room than the value of
'keymap', which might be long to distinguish between different languages,
keyboards and encodings.

The actual mappings are in the lines below "loadkeymap".  In the example "a"
is mapped to "A" and "b" to "B".  Thus the first item is mapped to the second
item.  This is done for each line, until the end of the file.
These items are exactly the same as what can be used in a |:lnoremap| command.
You can check the result with this command: >
	:lmap
The two items must be separated by white space.  You cannot include white
space inside an item, use the special names "<Tab>" and "<Space>" instead.
The length of the two items together must not exceed 200 bytes.

It's possible to have more than one character in the first column.  This works
like a dead key.  Example: >
                    'a     *
Since Vim doesn't know if the next character after a quote is really an "a",
it will wait for the next character.  To be able to insert a single quote,
also add this line: >
	''	'
Since the mapping is defined with |:lnoremap| the resulting quote will not be
used for the start of another character.

Although it's possible to have more than one character in the second column,
this is unusual.  But you can use various ways to specify the character: >
	A	a		literal character
	A	<char-97>	decimal value
	A	<char-0x61>	hexadecimal value
	A	<char-0141>	octal value
	x	<Space>		special key name

The characters are assumed to be encoded for the current value of 'encoding'.
It's possible to use ":scriptencoding" when all characters are given
literally.  That doesn't work when using the <char-> construct, because the
conversion is done on the keymap file, not on the resulting character.

The lines after "loadkeymap" are interpreted with 'cpoptions' set to "C".
This means that continuation lines are not used and a backslash has a special
meaning in the mappings.  Examples: >

	" a comment line
	\"	x	maps " to x
	\\	y	maps \ to y

If you write a keymap file that will be useful for others, consider submitting
it to the Vim maintainer for inclusion in the distribution:
<maintainer@vim.org>


HEBREW KEYMAP						*keymap-hebrew*

This file explains what characters are available in UTF-8 and CP1255 encodings,
and what the keymaps are to get those characters:

glyph   encoding	   keymap ~
Char   utf-8 cp1255  hebrew  hebrewp  name ~

my mozilla can't show the content correctly!!!!!

10. Using UTF-8				*mbyte-utf8* *UTF-8* *utf-8* *utf8*
								*Unicode*
The Unicode character set was designed to include all characters from other
character sets.  Therefore it is possible to write text in any language using
Unicode (with a few rarely used languages excluded).  And it's mostly possible
to mix these languages in one file, which is impossible with other encodings.

Unicode can be encoded in several ways.  The two most popular ones are UCS-2,
which uses 16-bit words and UTF-8, which uses one or more bytes for each
character.  Vim can support all of these encodings, but always uses UTF-8
internally.

Vim has comprehensive UTF-8 support.  It appears to work in:
- xterm with utf-8 support enabled
- Athena, Motif and GTK GUI
- MS-Windows GUI

Double-width characters are supported.  This works best with 'guifontwide' or
'guifontset'.  When using only 'guifont' the wide characters are drawn in the
normal width and a space to fill the gap.

Up to two combining characters can be used.  The combining character is drawn
on top of the preceding character.  When editing text a composing character is
mostly considered part of the preceding character.  For example "x" will
delete a character and its following composing characters by default. If the
'delcombine' option is on, then pressing 'x' will delete the combining
characters, one at a time, then the base character.  But when inserting, you
type the first character and the following composing characters separately,
after which they will be joined.  The "r" command will not allow you to type a
combining character, because it doesn't know one is coming.  Use "R" instead.

Bytes which are not part of a valid UTF-8 byte sequence are handled like a
single character and displayed as <xx>, where "xx" is the hex value of the
byte.

Overlong sequences are not handled specially and displayed like a valid
character.  However, search patterns may not match on an overlong sequence.
(an overlong sequence is where more bytes are used than required for the
character.)  An exception is NUL (zero) which is displayed as "<00>".

In the file and buffer the full range of Unicode characters can be used (31
bits).  However, displaying only works for 16 bit characters, and only for the
characters present in the selected font.

Useful commands:
- "ga" shows the decimal, hexadecimal and octal value of the character under
  the cursor.  If there are composing characters these are shown too. (if the
  message is truncated, use ":messages").
- "g8" shows the bytes used in a UTF-8 character, also the composing
  characters, as hex numbers.


STARTING VIM

If your current locale is in an utf-8 encoding, Vim will automatically start
in utf-8 mode.

If you are using another locale: >

	set encoding=utf-8

You might also want to select the font used for the menus.  Unfortunately this
doesn't always work.  See the system specific remarks below, and 'langmenu'.


USING UTF-8 IN X-Windows				*utf-8-in-xwindows*

You need to specify a font to be used.  For double-wide characters another
font is required, which is exactly twice as wide.  There are three ways to do
this:

1. Set 'guifont' and let Vim find a matching 'guifontwide'
2. Set 'guifont' and 'guifontwide'
3. Set 'guifontset'

See the documentation for each option for details.  Example: >

   :set guifont=-misc-fixed-medium-r-normal--15-140-75-75-c-90-iso10646-1

You might also want to set the font used for the menus.  This only works for
Motif.  Use the ":hi Menu font={fontname}" command for this. |:highlight|


TYPING UTF-8						*utf-8-typing*

If you are using X-Windows, you should find an input method that supports
utf-8.

If your system does not provide support for typing utf-8, you can use the
'keymap' feature.  This allows writing a keymap file, which defines a utf-8
character as a sequence of ASCII characters.  See |mbyte-keymap|.

Another method is to set the current locale to the language you want to use
and for which you have a XIM available.  Then set 'termencoding' to that
language and Vim will convert the typed characters to 'encoding' for you.

If everything else fails, you can type any character as four hex bytes: >

	CTRL-V u 1234

"1234" is interpreted as a hex number.  You must type four characters, prepend
a zero if necessary.


COMMAND ARGUMENTS					*utf-8-char-arg*

Commands like |f|, |F|, |t| and |r| take an argument of one character.  For
UTF-8 this argument may include one or two composing characters.  These needs
to be produced together with the base character, Vim doesn't wait for the next
character to be typed to find out if it is a composing character or not.
Using 'keymap' or |:lmap| is a nice way to type these characters.

The commands that search for a character in a line handle composing characters
as follows.  When searching for a character without a composing character,
this will find matches in the text with or without composing characters.  When
searching for a character with a composing character, this will only find
matches with that composing character.  It was implemented this way, because
not everybody is able to type a composing character.


==============================================================================
11. Overview of options					*mbyte-options*

These options are relevant for editing multi-byte files.  Check the help in
options.txt for detailed information.

'encoding'	Encoding used for the keyboard and display.  It is also the
		default encoding for files.

'fileencoding'	Encoding of a file.  When it's different from 'encoding'
		conversion is done when reading or writing the file.

'fileencodings'	List of possible encodings of a file.  When opening a file
		these will be tried and the first one that doesn't cause an
		error is used for 'fileencoding'

'charconvert'	Expression used to convert files from one encoding to another.

'formatoptions' The 'm' flag can be included to have formatting break a line
		at a multibyte character of 256 or higher.  Thus is useful for
		languages where a sequence of characters can be broken
		anywhere.

'guifontset'	The list of font names used for a multi-byte endoding.  When
		this option is not empty, it replaces 'guifont'.

'keymap'	Specify the name of a keyboard mapping.

==============================================================================

Contributions specifically for the multi-byte features by:
	Chi-Deok Hwang <hwang@mizi.co.kr>
	Nam SungHyun <namsh@lge.com>
	K.Nagano <nagano@atese.advantest.co.jp>
	Taro Muraoka  <koron@tka.att.ne.jp>
	Yasuhiro Matsumoto <mattn@mail.goo.ne.jp>

 vim:tw=78:ts=8:ft=help:norl:enc=euc-cn:
