*usr_03.txt*	For Vim version 6.2.     最后修改：2002年10月29日

			VIM 用户手册 － by Bram Moolenaar
			   (译者：Nek_in http://vimcdoc.sf.net)

				  移 动


在你插入或者删除之前，你需要移动到合适的位置。Vim 有一大堆命令可以移动光标。
本章向你介绍最重要的那些。你可以在 |Q_lr| 下面找到这些命令的列表。

|03.1|	词移动
|03.2|	移动到行首或行尾
|03.3|	移动到指定的字符
|03.4|	括号匹配
|03.5|	移动到指定的行
|03.6|	确定当前位置
|03.7|	滚屏
|03.8|	简单查找
|03.9|	简单的查找模式
|03.10|	使用标记

    下一章：|usr_04.txt|  做小改动
    前一章：|usr_02.txt|  Vim 初步
      目录：|usr_toc.txt|

==============================================================================
*03.1* 	词移动

要移动光标向前跳一个词，可以使用 "w" 命令。象大多数 Vim 命令一样，你可以在命令前
加数字前缀表示把这个命令重复多次。例如，"3w" 表示向前移动3个单词。用图表示如下：
>
	This is a line with example text ~
	  --->-->->----------------->
	   w  w  w    3w
<
要注意的是，如果光标已经在一个单词的词首，"w" 移动到下一个单词的词首。
    "b" 命令向后移动到前一个词的词首：

	This is a line with example text ~
	<----<--<-<---------<---
	   b   b b    2b      b

还有一个 "e" 命令可以移到下一个单词的词末，而 "ge" 则移动到前一个单词的末尾：

	This is a line with example text ~
	   <-   <--- ----->   ---->
	   ge    ge     e       e

如果你在一行的最后一个单词，"w" 命令将把你带到下一行的第一个单词。这样你可以
用这个命令在一段中移动，这比使用 "l" 要快得多。"b" 则在反方向完成这个功能。

一个词以非单词字符结尾，例如 "."，"-" 或者 ")"。要改变 Vim 使用的 "分词符"，
请参见 'iskeyword' 选项。
    还可以以 "空白字符" 分割的 "大单词" 移动。这不是我们通常意义的 "单词”。这
就是为什么称之为 "大单词" 的原因。如下图所示：

	       ge      b	  w				e
	       <-     <-	 --->			       --->
	This is-a line, with special/separated/words (and some more). ~
	   <----- <-----	 -------------------->	       ----->
	     gE      B			 W			 E
               ge      b          w                             e

组合运用这些大写和小写的命令，你可以很快地在一段中前后移动。

==============================================================================
*03.2*	移动到行首或行尾

"$" 命令把光标移动到当前行行尾。如果你的键盘上有 <End> 键，也可以完成相同的功能。

"^" 命令把光标移动到当前行的第一个非空字符，而 "0" 命令则移到一行的第一个字符，
<Home> 键也可以完成相同的功能。图示如下：

		  ^
	     <------------
	.....This is a line with example text ~
	<-----------------   --------------->
		0		   $

（这里 "....." 表示空白字符）

    象大多数移动命令一样，"$" 命令接受个次数前缀。但是 "移动到一行的行尾n次" 没
有什么意义，所以它会使光标移动到另一行。例如，"1$" 移动到当前行的行尾，而
"2$" 则移动到下一行的行尾，如此类推。
    "0" 命令不能加个数前缀，因为 "0" 本身就是个数字。而且，出人意料地是，"^" 命
令也不支持数字前缀。

==============================================================================
*03.3*	移动到一个指定的字符

单字符查找命令是最有用的移动命令之一。"fx" 命令向前查找本行中的字符 x。提示：
"f" 表示 "Find"。
    例如，假定你在下面例子行的行首，而你想移动到单词 "human" 的h那里。只要执行
命令 "fh" 即可：

	To err is human.  To really foul up you need a computer. ~
	---------->--------------->
	    fh		 fy

这个例子还演示了用 "fy" 命令移动到 "really" 的词尾。
    你可以在这个命令前面加数字前缀，所以，你可以用 "3fl" 命令移动到 "foul" 的
"l":

	To err is human.  To really foul up you need a computer. ~
		  --------------------->
			   3fl

"F" 命令用于向左查找：

	To err is human.  To really foul up you need a computer. ~
		  <---------------------
			    Fh

"tx" 命令与 "fx" 相似，但它只把光标移动到目标字符的前一个字符上。提示："t"
表示 "To"。这个命令的反向版本是 "Tx"。

	To err is human.  To really foul up you need a computer. ~
		   <------------  ------------->
			Th		tn

这四个命令可以通过 ";" 命令重复，"," 命令则用于反向重复。无论用哪个命令，光标
永远都不会移出当前行，哪怕是这两行是连续的一个句子。

有时你启动了一个查找命令后才发现自己执行了一个错误的命令。例如，你启动了一个
"f" 命令后才发现你本来想用的是 "F"。要放弃这个查找，输入 <Esc>。所以
"f<Esc>" 取消一个向前查找命令而不做任何操作。 Note: <Esc> 可以中止大部分命令，
而不仅仅是查找。

==============================================================================
*03.4*	括号匹配

当你写程序的时候，你经常会遇到嵌套的()结构。这时，"%" 是一个非常方便的命令
了：它能匹配一对括号。如果光标在 "(" 上，它移动到对应的 ")" 上，反之，如果它在
")" 上，它移动到 "(" 上。

			    %
			 <----->
		if (a == (b * c) / d) ~
		   <---------------->
			    %

这个命令也可适用于 [] 和 {}。（可用'matchpairs'选项定义）

当光标不在一个有用的字符上，"%" 会先向前找到一个。比如当光标停留在上例中的行
首时，"%" 会向前查找到第一个 "("。然后会移动到它的匹配处。

		if (a == (b * c) / d) ~
		---+---------------->
			   %

===============================================================================
*03.5*	移动到指定的行

如果你是一个 C 或者 C++ 程序员，你对下面这样的错误信息应该非常熟悉：

	prog.c:33: j   undeclared (first use in this function) ~

这表示你可能要移动到 33 行去作一些修改了。那么怎样找到 33 行？一个办法是执行
"9999k" 命令移到文件头，再执行 "32j" 下移到32行。这不是一个好办法，但肯定有效。
更好的方法是使用 "G" 命令。加上一个次数前缀，这个命令可以把你送到指定的行。
例如，"33G" 把你送到 33 行。(要用更好的方法在编译器的错误列表中移动，参见
|usr_30.txt| 的 ":make" 命令部分。)
    如果没有数字前缀，"G" 命令把光标移动到文末。移动到文首的命令是 "gg"。"1G"
也能完成这个功能，但稍复杂一点。

	    |	first line of a file   ^
	    |	text text text text    |
	    |	text text text text    |  gg
	7G  |	text text text text    |
	    |	text text text text
	    |	text text text text
	    V	text text text text    |
		text text text text    |  G
		text text text text    |
		last line of a file    V

另一个定位行的方法是使用带数字前缀的 "%" 命令。例如，"50％" 移动到文件的中间，
而 "90%" 移到差不多结尾的位置。

前面的描述假定你想移动到文件中的某一行，而不在乎它是否可见。那么如何移动到视野
之内的一行呢？下图演示了三个可以使用的命令：

			+---------------------------+
		H -->	| text sample text	    |
			| sample text		    |
			| text sample text	    |
			| sample text		    |
		M -->	| text sample text	    |
			| sample text		    |
			| text sample text	    |
			| sample text		    |
		L -->	| text sample text	    |
			+---------------------------+

提示："H" 表示 "Home"，"M" 表示 "Middle" 而 "L" 表示 "Last"。

==============================================================================
*03.6*	确定当前位置

要确定你在文件中的位置，有三种方法：

1.  使用 CTRL-G 命令，你会获得如下消息(假定 'ruler' 选项已经被关闭)：

	"usr_03.txt" line 233 of 650 --35%-- col 45-52~

    这里显示了你正在编辑的文件的名称，你所处的当前行的行号，全文的总行数，光标
    以前的行占全文的百分比，和你所处的列的列号。
    有时你会看到一个分开的两个列号。例如，"col 2-9"。这表示光标处于第二个字符
    上，但由于使用了制表符，在屏幕上的位置是 9。

2. 设置 'number' 选项。这会在每行的前面加上一个行号：
>
	:set number
<
    要重新关闭这个选项：
>
	:set nonumber
<
    由于'number'是一个布尔类型的选项，在它前面加上 "no" 表示关闭它。布尔选项只会
    有两个值，on 或者 off。
      Vim 有很多选项，除了布尔类型的，还有数字或者字符串类型的。在用到的时候会给
    处一些例子的。

3.  设置 'ruler' 选项。这会在 Vim 窗口的右下角显示当前光标的位置：
>
	:set ruler
<
使用 'ruler' 的好处是它不占多少地方，从而可以留下更多的地方给你的文本。

=================================================================================
*03.7*	滚屏

CTRL-U 命令向下滚动半屏。想象一下通过一个视口看着你的文本，然后把这个视口向上移动
该视口的一半高度。这样，窗口移动到当前文字的上面，而文字则移到窗口的下面。不用担心
记不住那边是上。很多人都是这样。
    CTRL-D命令把视窗向下移动半屏，所以把文字向上移动半屏。
>
				       +----------------+
				       | some text	|
				       | some text	|
				       | some text	|
	+---------------+	       | some text	|
	| some text	|  CTRL-U  --> |		|
	|		|	       | 123456		|
	| 123456	|	       +----------------+
	| 7890		|
	|		|	       +----------------+
	| example	|  CTRL-D -->  | 7890		|
	+---------------+	       |		|
				       | example	|
				       | example	|
				       | example	|
				       | example	|
				       +----------------+

每次滚一行的命令是 CTRL-E（上滚）和 CTRL-Y（下滚）。可以把 CTRL-E 想象为是多给你
一行（one line Extra）。

向前滚动一整屏的命令是 CTRL-F（实际上会留下两行不滚动）。反向的命令是 CTRL-B。
幸运地，CTRL-F 是向前 (forward) 滚动，CTRL-B 是向后 (backward) 滚动，这比较好记。

移动中的一个常见问题是，当你用 "j" 向下移动的时候，你的光标会处于屏幕的底部，
你可能希望，光标所在行处于屏幕的中间。这可以通过 "zz" 命令实现。
>
	+------------------+		 +------------------+
	| some text	   |		 | some text	    |
	| some text	   |		 | some text	    |
	| some text	   |		 | some text	    |
	| some text	   |   zz  -->	 | line with cursor |
	| some text	   |		 | some text	    |
	| some text	   |		 | some text	    |
	| line with cursor |		 | some text	    |
	+------------------+		 +------------------+
<
"zt" 把光标所在行移动到屏幕的顶部，而 "zb" 则移动到屏幕的底部。Vim 中还有另外
一些用于滚动的命令，可以参见|Q_sc|。要使光标上下总保留有几行处于视口中用作上下
文，可以使用'scrolloff'选项。

==============================================================================
*03.8*	简单查找

查找命令是 "/String"。例如，要查找单词 "include"，使用如下命令： >

	/include

你会注意到，当你输入 "/" 的时候，光标移到了 Vim 窗口的最后一行，这与 "冒号命令"
一样，在那里你可以输入要查找的字符串。你可以使用退格键 (退格箭头或<BS>) 进行
修改，如果需要的时候还可以使用 <Left> 和 <Right> 键。
   使用 <Enter> 开始执行这个命令。

	Note:
	字符.*[]^%/\?~$有特殊含义。如果你要查找它们，需要在前面加上一个 "\"。
	请参见下文。

要查找下一个匹配可以使用 "n" 命令。用下面命令查找光标后的第一个 #include： >

	/#include

然后输入 "n" 数次。你会移动到后面每一个 #include。如果你知道你想要的是第几个，
可以在这个命令前面增加次数前缀。这样，"3n" 表示移动到第三个匹配点。要注意，
"/" 不支持次数前缀。

"?" 命令功能与 "/" 的功能类似，但是是反方向查找： >

	?word

"N" 命令在反方向重复前一次查找。因此，在 "/" 命令后执行 "N" 命令是向后查找，
在 "?" 命令后执行 "N" 命令是向前查找。


忽 略 大 小 写

通常，你必须区分大小写地输入你要查找的内容。但如果你不在乎大小写。可以设置
'ignorecase' 选项： >

        :set ignorecase

如果你现在要查找 "word"，它将匹配 "word" 和 "WORD"。如果想再次区分大小写: >

	:set noignorecase


历 史 记 录

假设你执行了三个查找命令： >

	/one
	/two
	/three

现在，让我们输入 "/" 启动一次查找，但先不按下回车键。现在按 <Up>（上箭头），Vim
把 "/three" 放到你的命令行上。回车就会从当前位置查找 "three"。如果你不回车，
继续按 <Up>，Vim 转而显示 "/two"，而下一次 <Up> 变成 "/one"。
    你还可以用 <Down> 命令在历史记录中反向查找。

如果你知道前面用过的一个模式以什么开头，而且你想再使用这个模式的话，可以在输入
<Up> 前输入这个开头。继续前面的例子，你可以输入 "/o<Up>"，Vim 就会在命令行上
显示 "/one"。

冒号开头的命令也有历史记录。这允许你取回前一个命令并再次执行。这两种历史记录
是相互独立的。


在 文 本 中 查 找 一 个 单 词

假设你在文本中看到一个单词 "TheLongFunctionName" 而你想找到下一个相同的单词。
你可以输入 "/TheLongFunctionName"，但这要输入很多东西。而且如果输错了，Vim
是不可能找到你要找的单词的。
    有一个简单的方法：把光标移到那个单词下面使用 "*" 命令。Vim 会取得光标上
的单词并把它作为被查找的字符串。
    "#" 命令在反向完成相同的功能。你可以在命令前加一个次数："3*" 查找光标下
单词第三次出现的地方。


查 找 整 个 单 词

如果你输入 "/the"，你也可能找到 "there"。要找到以 "the" 结尾的单词，可以用： >

	/the\>

"\>" 是一个特殊的记号，表示只匹配单词末尾。类似地，"\<" 只匹配单词的开头。
这样，要匹配一个完整的单词 "the"，只需： >

	/\<the\>

这不会匹配 "there" 或者 "soothe"。注意 "*" 和 "#" 命令也使用了 "词首" 和 "词尾" 
标记来匹配整个单词（要部分匹配，使用 "g*" 和 "g#"）


高 亮 匹 配

当你编辑一个程序的时候，你看见一个变量叫 "nr"。你想查一下它在哪被用到了。你可以
把光标移到 "nr" 下用 "*" 命令，然后用 n 命令一个个遍历。
    这里还有一种办法。输入这个命令： >

	:set hlsearch

现在如果你查找 "nr"，Vim会高亮显示所有匹配的地方。这是一个很好的确定变量在哪被使
用，而不需要输入更多的命令的方法。
    要关掉这个功能： >

	:set nohlsearch

然后你又需要在下一次查找的时候又切换回来。如果你只是想去掉高亮显示的东西，用如下
命令： >

	:nohlsearch

这不会复位 hlsearch 选项。它只是关闭高亮显示。当你执行下一次查找的时候，高亮功能
会被再次激活。使用 "n" 和 "N" 命令时也一样。

调 节 查 找 方 式

有一些选项能改变查找命令的工作方式。其中有几个是最基本的： 
>
	:set incsearch

这个命令使 Vim 在你输入字符串的过程中就显示匹配点。用这个可以检查正确的地方是否已经
被找到了。然后输入 <Enter> 跳到那个地方。或者继续输入更多的字符改变要被查找的字符串。
>
	:set nowrapscan

这个选项在找到文件结尾后停止查找。或者当你往回查找的时候遇到文件开头停止查找。默认
情况下 'wrapscan' 的状态是 "on"。所以在找到文件尾的时候会自动折返。


插 曲

如果你喜欢前面的选项，而且每次用 Vim 都要设置它，那么，你可以把这些命令写到
Vim 的启动文件中。
    编辑 |not-compatible| 中提到的文件，或者用如下命令确定这个文件在什么地方： >

	:scriptnames

编辑这个文件，例如，象下面这样：  >

	:edit ~/.vimrc

然后在文中加一行命令来设置这些选项，就好像你在 Vim 中输入一样，例如： >

	Go:set hlsearch<Esc>

"G" 移动到文件的结尾，"o" 开始一个新行，然后你在那里输入 ":set" 命令。
最后你用 <Esc> 结束插入模式。然后用如下命令存盘： >

	ZZ

现在如果你重新启动 Vim，'hlsearch' 选项就已经被设置了。

============================================================================
*03.9*	简单的查找模式

Vim 用正则表达式来定义要查找的对象。正则表达式是一种非常强大和紧凑的定义查找模式
的方法。但是非常不幸，这种强大的功能是有代价的，因为使用它需要掌握一些技巧。
    本章我们只介绍一些基本的正则表达式。要了解更多的关于查找模式和命令，请参考
|usr_27.txt|。你还可以在|pattern|中找到正则表达式的完整描述。

行 首 与 行 尾

^字符匹配行首。在美式英文键盘上，它在数字键 6 的上面。模式 "include" 匹配一行中
任何位置的单词 include。而模式 "^include" 仅匹配在一行开始的 include。
    $字符匹配行尾。所以，"was$" 仅匹配在行尾的单词 was。

我们在下面的例子中用 "x" 标记出被 "the" 模式匹配的位置：

	the solder holding one of the chips melted and the ~
	xxx			  xxx		       xxx

用 "/the$" 则匹配如下位置：

	the solder holding one of the chips melted and the ~
						       xxx

而使用 "/^the" 则匹配：

	the solder holding one of the chips melted and the ~
	xxx

你还可以试着用这个模式： "/^the$"，它会匹配仅包括 "the" 的行。并且不包括空格。
例如包括 "the " 的行是不会被这个模式匹配的。

匹 配 任 何 单 个 字 符

点 "." 字符匹配任何字符。例如，模式 "c.m" 匹配一个第一个字符是c，第二个字符是
任意字符，而第三个字符是m的字符串。例如：

	We use a computer that became the cummin winter. ~
		 xxx		 xxx	  xxx


匹 配 特 殊 字 符

如果你确实想匹配一个点字符，你可以在前面加一个反斜杠去消除它的特殊含义。
    如果你用 "ter." 为模式去查找，你会匹配这些地方：

	We use a computer that became the cummin winter. ~
		      xxxx			    xxxx

但如果你查找 "ter\."，你只会匹配第二个位置。

==============================================================================
*03.10*	使用标记

当你用 "G" 命令跳到另一个地方，Vim 会记住你从什么地方跳过去的。这个位置成为一个
标记，要回到原来的地方，使用如下命令： >

	``

` 用单引号 ' 也可以。
   如果再次执行这个命令你会跳回去原来的地方，这是因为 ` 记住了自己跳转前的位置。
通常，每次你执行一个会将光标移动到本行之外的命令，这种移动即被称为一个 "跳转"。
这包括查找命令 "/" 和 "n"（无论跳转到多远的地方）。但不包括 "fx" 和 "tx" 这些
行内查找命令或者 "w" 和 "e" 等词移动命令。
    另外 "j" 和 "k" 不会被当做是一次 "跳转"，即使你在前面加上个数前缀也不例外。
``命令可以在两个位置上跳来跳去。而 CTRL-O 命令则跳到一个 "较老" 的地方（提示：O
表示older）。CTRL-I 则跳到一个 "较新" 的地方（提示：I在键盘上紧靠着O）。考虑一下
如下命令序列： >

	33G
	/^The
	CTRL-O

你首先跳到第 33 行，然后查找以 "The" 开头的一行，然后用 CTRL-O 你会跳回到 33 行。
再执行 CTRL-O 你会跳到最初的地方。现在你使用 CTRL-I，就又跳到 33 行。而再用一次
CTRL-I 你又会到达找到 "The" 的地方。


	     |	example text   ^	     |
	33G  |	example text   |  CTRL-O     | CTRL-I
	     |	example text   |	     |
	     V	line 33 text   ^	     V
	     |	example text   |	     |
       /^The |	example text   |  CTRL-O     | CTRL-I
	     V	There you are  |	     V
		example text

	Note:
	CTRL-I的功能与<Tab>一样。

":jumps" 命令能输出一个你可以跳往的位置的列表。最后一个你使用的到的标记会用
">" 符号标记出来。


有 名 字 的 标 记

Vim 允许你在文本中放置自定义的标记。命令 "ma" 用 a 标记当前的光标位置。你可以在
文本中使用 26 个标记（a到z）。这些标记是不可见的，只是一个由 Vim 记住的位置。
    要跳到一个你定义的标记，可以使用命令 `{mark}，这里 {mark} 是指定义标记
的那个字母。所以，移到标记a的命令是： >

	`a

命令 'mark（单引号加上一个标记）会移到标记所在行的行首。这与 `mark 命令是不同的，
后者是移到标记所在行上被标记的列。

标记在需要处理一个文件的两个相关地方的时候非常有用。假设你在处理文末的时候需要
查看文首的一些内容，先移动到行首，设置一个标记 s (start)： >

	ms

然后移动到你需要处理的地方，再设置一个标记 e (end)： >

	me
<
现在你可以随意移动，当你需要看开头的地方，可以使用这个命令移到那里： >

	's

然后使用 '' 跳回来。或者用 'e 跳到你正在处理的文尾的地方。
    这里使用 s 和 e 作标记名没有特别的含义，只是为了好记而已。

你可以用如下命令取得所有的标记的列表： >

	:marks

你会注意到有一些特殊的标记，包括：

	'	跳转前的位置
	"	最后编辑的位置
	[	最后修改的位置的开头
	]	最后修改的位置的结尾

===============================================================================

下一章：|usr_04.txt|  作小改动

版权： 参见|manual-copyright|   vim:tw=78:ts=8:ft=help:norl:enc=euc-cn:
