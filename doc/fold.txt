*fold.txt*      For Vim version 6.2.  最后修改: 2002年4月1日


		  VIM 参考手册    作者：Bram Moolenaar
		                  翻译：Zimin<cranecai@users.sf.net> 
		                  VCD主页：http://vimcdoc.sf.net


折叠						*Folding* *folding*

你可以在用户手册的第28章找到有关折叠的序论。
|usr_28.txt|

1. 折叠方法		|fold-methods|
2. 折叠命令		|fold-commands|
3. 折叠选项		|fold-options|
4. 折叠表现		|fold-behavior|

{Vi has no Folding}
{not available when compiled without the +folding feature}

==============================================================================
1. 折叠方法					*fold-methods*

可用选项 'foldmethod' 来设定折叠方法。

当选项 'foldmethod' 不设为 "manual" 时，所有的折叠被删除并且创建新的。如果设置
成了 "manual"，将不除去已有的折叠。这可被自动定义折叠，然后手工改变之。

有6种方法来选定折叠：
	manual		手工定义折叠
	indent		更多的缩进表示更高级别的折叠
	expr		用表达式来定义折叠
	syntax		用语法加亮来定义折叠
	diff		对没有更改的文本进行折叠
	marker		对文中的标记折叠


手 工						*fold-manual*

使用命令来手工定义要折叠的范围。分析文字以发现折叠的脚本，也可用这种方法。

折叠的级别仅由牵套次数来定义。要对一定行数的折叠增加级别，可以在相同的几行里再
定义折叠。

当你退出文件编辑时，手工折叠会丢失。要保存折叠，使用 |:mkview|命令。之后，要恢
复使用 |:loadview| 。


缩 进						*fold-indent*

由缩进行自动定义折叠。

折叠级别由缩进行计算而得，用 'shiftwidth' （循环往复的）划分。连续的、有同样或
更高的折叠级别的行，形成一个折叠。在其中，有更高折叠级别的行形成牵套的折叠。

牵套的级别数受 'foldnestmax' 选项限制。

当折叠级别是最低时，这些行被省略，且这些行得到上一行或下一行的折叠级别。这些就
是空或只有空格的行和那些以在 'foldignore' 里包含的字符开始的行。在查找 
'foldignore' 里包含的字符时，空格被跳过。象 C 使用 "#" 来略过要预处理的那些行
。

当你想用另一种方式来略过行时，使用 'expr' 方法。在 'foldexpr' 中可使用
|indent()| 来取得一行的缩进。


表 达 式						*fold-expr*

就象用 "indent" 方式一样，表达式方式的折叠也是由折叠级别自动定义的。选项
'foldexpr' 的值被计算，以此作为一行的折叠级别。如：
对所有以 Tab 符开始的连续的几行，创建折叠： >
	:set foldexpr=getline(v:lnum)[0]==\"\\t\"
调用一函数来计算折叠级别：  >
	:set foldexpr=MyFoldLevel(v:lnum)
折叠用空行分开的段落：  >
	:set foldexpr=getline(v:lnum)=~'^\\s*$'&&getline(v:lnum+1)=~'\\S'?'<1':1
同上：  >
	:set foldexpr=getline(v:lnum-1)=~'^\\s*$'&&getline(v:lnum)=~'\\S'?'>1':1
注意：对 escape 类的字符必须使用反斜杠符。它们的处理由 ":set" 来决定，而有所不
同（空格，反斜杠，双引号，等等，参考 |option-backslash|）

这些是表达式的计算条件：
- 当前缓冲和窗口是为了行而设
- 变量 "v:lnum" 表示行号
- 用以下方式将结果用于折叠级别中：
  value			meaning ~
  0			这行不用折叠
  1, 2, ..		这行的折叠级别1，2
  -1折叠级别没有定义，使用这行之前或之后一行的级别值，取较低的一个。
  "="			使用上一级的折叠级别。
  "a1", "a2", ..	上一行的折叠级别加1，2，..
  "s1", "s2", ..	上一行的折叠级别减1，2，..
  "<1", "<2", ..	这个折叠级别的在这行结束折叠
  ">1", ">2", ..	这个折叠级别的在这行开始折叠

不需要用 ">1"（"<1"）标记折叠的开始（结束）。当这行折叠级别高于（低于）上一行
的级别时，折叠将开始（结束）。

使用表达式必须没有副作用。在缓冲里的文字，光标位置，查找模式，选项等等，必须没
有变化。

如果在表达式中有错误，或者计算结果不能识别，不会产生错误消息，折叠级别将设为0
。当要调试时，可将 'debug' 选项设为 "msg"，错误消息就可以被见到了。

注意：由于每一行关于表达式的值都要被计算，这很耗费时间！

试着避免 "=" ， "a" 和 "s" 作为返回值，因为 Vim不得不经常向后回朔以得到折叠级
别。使用 foldlevel() 可能有所帮助。如： >
	" extra is level compared to previous line
	let lvl = foldlevel(v:lnum - 1)
	if lvl >= 0
	  return lvl + extra
	endif
	" return "=", "a" or "s"


语 法						*fold-syntax*

由带有 "fold" 参数的语法项来定义折叠。|:syn-fold|

折叠级别由牵套的折叠数来定义。牵套数由 'foldnestmax' 限定。


比 较						*fold-diff*

折叠由没有改变的文本或靠近改变的文本自动定义。

这个方法仅适用于当前窗口的 'diff' 选项被设定且不同之处被显示时才有效。不然，整
给缓冲就是一个大的折叠。

选项 'diffopt' 可以指定上下文。就是说，在折叠和不同之处所间隔的行数。如，设定
上下文为8： >
默认值是6。


标 记						*fold-marker*

在文本中标记指明了哪里是折叠的开始和结束。这可以让你精确的定义折叠。这也可以让
你删除和加入一些行进入折叠，而不产生错误。选项 'foldtext' 决定了在被折叠的行之
前的文本。这使命名一处折叠成为可能。

标记可以包含级别数，也可以使用匹配对。包含级别数较简单，你无须添加结束标记，并
可以避免标记不配对的问题。如： >
	/* global variables {{{1 */
	int varA, varB;

	/* functions {{{1 */
	/* funcA() {{{2 */
	void funcA() {}

	/* funcB() {{{2 */
	void funcB() {}

折叠开始于 "{{{" 标记。接下去的数字决定了折叠级别。产生的效果依赖于当前折叠级
别和由标记给定的级别的区别而定：
1. 如果遇到级别相同，上一个折叠结束，另一个有同样级别的折叠开始。
2. 如果标记的级别高，一个牵套的折叠开始。
3. 如果标记的级别低，所有高于当前级别也包括当前级别的折叠结束，且指定级别的折
   叠开始。

数字指定了折叠级别。0 不能使用。
你可以使用 "}}}" 带上一个数字来表示这个级别的折叠结束。此行以下的折叠级别将小
于当前指定的级别。注意：Vim 不会回朔匹配的标记（这将耗费太多的时间）。如： >

	{{{1
	fold level here is 1
	{{{3
	fold level here is 3
	}}}3
	fold level here is 2

你也可以用一对匹配标记 "{{{" 和 "}}}" 来定义折叠。每个 "{{{" 使折叠级别加1，
"}}}" 使折叠级别减1。注意：要使标记配对！如： >

	{{{
	fold level here is 1
	{{{
	fold level here is 2
	}}}
	fold level here is 1

带数字的标记和没有带数字的标记可以混合使用。对于一个大折叠我们可以使用带数字的
标记，在一个函数里我们可以使用不带数字的。如对 "structure definitions"， 
"local variables" 和 "functions" 使用级别1的折叠。对定义和函数使用级别2的标记
。在函数内使用不带数字的标记。当你在一函数中作更改以分割折叠时，你无须记着标记
。

选项 'foldmarker' 可设定标记。建议保留默认值 "{{{,}}}" ，以此可以在 Vim 使用者
间交换文件。仅当文件需要时才改变之（如，它包含了来自另一个折叠的标记，或对于当
前文件的语言折叠标记会产生歧义）。

							*fold-create-marker*
"zf" 可通过标记来创建一个折叠。 Vim 将为你插入标记。 Vim 将附上开始和结束标记
，这些标记由 'foldmarker' 指定。标记被加在一行末。如果 'commentstring' 不为空
，就使用它。
在以下情况，可能无法正常工作：
- 此行已有一个带数字的标记了。Vim 无法判断该如何做。
- 在附近的折叠里使用了带数字的标记，使添加被阻。
- 这行包含在一注释中，且 'commentstring' 不为空，且牵套的注释不可用。如，在 C
  的注释中加入 /* {{{ */ ，这将使现有的注释中断。你可以在注释之前或之后添加，
  或手工添加。
总的来说，当你已有带数字的标记时，再让 Vim 为你创建标记不是个好主意。

							*fold-delete-marker*
"zd" 可用来删除一个用标记定义的折叠。 Vim 将为你删除标记。遵照 'flodmarker' 
Vim 将在折叠的开始和结束处查找开始和结束标记。当在标记周围的文字同 
'commentstring' 匹配，这些文字也被删除。
但在以下情况无法执行：
- 当一行包含有多于一个的标记且其中一个指定了级别。不考虑是否是想要的结果，仅删
  除第一个标记。
- 当这个标记包含带有数字且同时被用来开始或结束几个折叠时。

==============================================================================
2. 折叠命令				*fold-commands* *E490*

所有的折叠命令用 "z" 开头。提示：如果你从一侧看 "z" 象些叠起来的纸。


创 建 和 删 除 折 叠 ~
							*zf* *E350*
zf{motion}  or
{Visual}zf	创建折叠
		仅当 'foldmethod' 设为 "manual" 或 "marker"时有效。
		用 "manual" 方式，可将新的折叠关闭。
		'foldenable' 被置起。
		也可参考 |fold-create-marker|。

							*zF*
zF		对 N 行创建折叠。如 "zf" 。

:{range}fo[ld]						*:fold* *:fo*
		对 {range} 内的行创建折叠。如 "zf" 。

							*zd* *E351*
zd		删除在光标下的折叠。当光标在被折叠的行上，该折叠被删除。牵套的
		折叠上移一级。在可视模式下（基本上）所有在所选区域的折叠都被删除
		。注意：这种一次删除多个折叠的简单方法，其结果不可恢复。
		仅当 'foldmethod' 设为 "manual" 或 "marker"时有效。
		也可参考 |fold-delete-marker|。

							*zD*
zD		循环删除光标下的折叠。在可视模式下（基本上）所有在所选区域的折
		叠和牵套的折叠都被删除。
		仅当 'foldmethod' 设为 "manual" 或 "marker"时有效。
		也可参考 |fold-delete-marker|。

							*zE* *E352*
zE		除去所有在窗口里的折叠。
		仅当 'foldmethod' 设为 "manual" 或 "marker"时有效。
		也可参考 |fold-delete-marker|。


打 开 和 关 闭 折 叠 ~

一个小于 'foldminlines' 的折叠的显示就象它打开时的一样。所以，以下的命令对于小
折叠所起的作用与描述不同。

							*zo*
zo		打开在光标下的折叠。当给定一个数字时，相应深度的折叠被打开。在
		可视模式下，所选区域的所有行的一级折叠被打开。

							*zO*
zO		循环打开光标下的折叠。不在光标下的折叠不改变。
		在可视模式下，打开所有的在选中区域里的折叠，包括被部分选中的。

							*zc*
zc		关闭在光标下的折叠。当给定一个数字时，相应深度的折叠被关闭。在
		可视模式下，所选区域里的所有行的一级折叠被删除。
		'foldenable' 被置起。

							*zC*
zC		循环关闭在光标下的所有折叠。不在光标下的折叠不改变。
		在可视模式下，关闭所有的在选中区域里的折叠，包括被部分选中的。
		'foldenable' 被置起。

							*za*
za		当处在一关闭的折叠上时，打开之。当折叠牵套时，你可以使用 "za"
		几次。当给定一个数字时，打开相应数量的被关闭的折叠。
		当处在一打开的折叠上时，关闭之且置起 'foldenable' 。这仅关闭一
		级折叠，因为再次使用 "za" 将再次打开折叠。当给定一个数字时，关
		闭相应数量的折叠（这不同于重复 "za" 许多次）。

							*zA*
zA		当处在一关闭的折叠上时，循环的打开折叠。
		当处在一打开的折叠上时，循环的关闭折叠且置起 'foldenable' 。

							*zv*
zv		查看光标所在的行：仅打开足够的折叠使光标所在的行没有被折叠。

							*zx*
zx		更新折叠：手工恢复被打开和关闭的折叠：再次使用 'foldlevel'，然
		后使用 "zv" ：查看光标所在行。

							*zX*
zX		手工恢复被打开和关闭的折叠：再次使用 'foldlevel'

							*zm*
zm		多折叠：'foldlevel' 减1。如果 'foldlevel' 已经为0，则不减。
		'foldenable' 被置起。

							*zM*
zM		关闭所有折叠：'foldlevel' 设为0。
		'foldenable' 被置起。

							*zr*
zr		少折叠： 'foldlevel'加1。

							*zR*
zR		打开所有的折叠。'foldlevel' 设为最高级别。

							*:foldo* *:foldopen*
:{range}foldo[pen][!]
		在 {range} 内打开折叠。当加上 [!] 时，所有的折叠都被打开。对查
		看在 {range} 内的所有文本很有用。没有 [!] 时，打开折叠的一级。

							*:foldc* *:foldclose*
:{range}foldc[lose][!]
		在 {range} 内关闭折叠。当加上 [!] 时，所有的折叠都被关闭。对隐
		藏在 {range} 内的所有文本很有用。没有 [!] 时，关闭折叠的一级。

							*zn*
zn		不折叠：重置 'foldenable'。所有的折叠被打开。

							*zN*
zN		一般折叠：置起 'foldenable' 。所有的折叠都展现它们之前的样子。

							*zi*


在 折 叠 间 移 动 ~
							*[z*
[z		到当前打开的折叠的开始。如果已在开始处，移到包含这个折叠的折叠
		开始处。如果没有包含他的折叠，命令执行失败。
		当给定一数字，重复此命令 N 次。

							*]z*
[z		到当前打开的折叠的结束。如果已在结束处，移到包含这个折叠的折叠
		结束处。如果没有包含他的折叠，命令执行失败。
		当给定一数字，重复此命令 N 次。

							*zj*
zj		向下移动。到达下一个折叠的开始处。关闭的折叠也被计入。
		当给定一数字，重复此命令 N 次。
		此命令可在 |operator| 后使用。

							*zk*
zk		向上移动到前一折叠的结束处。关闭的折叠也被计入。
		当给定一数字，重复此命令 N 次。
		此命令可在 |operator| 后使用。


对 折 叠 执 行 命令 ~

:[range]foldd[oopen] {cmd}			*:foldd* *:folddoopen*
		对所有不在关闭的折叠中的所有行，执行 {cmd} 。
		给定 [range] 时，仅对那些行起作用。
		每次命令被执行时，光标就在那要被操作的行上。
		就如 ":global" 命令：首先标记出所有不在关闭的折叠中的行。然后
		对所有标记过的行，执行 {cmd}。所以当 {cmd} 改变了文本的折叠时
		，对命令执行的位置没有影响（当然，删除行例外）。
		如： >
			:folddoopen s/end/loop_end/ge
<		使用标志 "e" 要避免当 "end" 不匹配时得到错误消息。

:[range]folddoc[losed] {cmd}			*:folddoc* *:folddoclosed*
		对所有在关闭的折叠里的行，执行 {cmd} 。
		就象 ":folddoopen" 的逆

==============================================================================
3. 折叠选项					*fold-options*

颜 色							*fold-colors*

对关闭的折叠的颜色的设定由 |hl-Folded| 决定。对折叠栏的颜色的设定由 
|hl-FoldColumn| 决定。
下面是设定颜色的例子： >

	:highlight Folded guibg=grey guifg=blue
	:highlight FoldColumn guibg=darkgrey guifg=white


折 叠 级 别						*fold-foldlevel*

'foldlevel' 是个数字选项：数字越大则打开的折叠更多。
当 'foldlevel' 为0时，所有的折叠关闭。
当 'foldlevel' 为正数时，一些折叠关闭。
当 'foldlevel' 很大时，所有的折叠打开。
'foldlevel' 的改变生效后，手工的折叠就可以打开和关闭。
当其值变大，在新级别之上的折叠被打开。没被手工打开的折叠会被关闭。
当其值变小，在新级别之上的折叠被关闭。没被手工关闭的折叠会被打开。


折 叠 文 本						*fold-foldtext*

'folftext' 是个字符串选项，定义了一个表达式。这个表达式是用来对关闭得折叠求得
它的显示文字的。如： >

    :set foldtext=v:folddashes.substitute(getline(v:foldstart),'/\\*\\\|\\*/\\\|{{{\\d\\=','','g')

显示了折叠的第一行，除去其中的 "/*", "*/" 和 "{{{" 。
注意：使用反斜杠是为了避免一些字符被 ":set" 命令解释。定义一个函数来调用更简单
： >

    :set foldtext=MyFoldText()
    :function MyFoldText()
    :  let line = getline(v:foldstart)
    :  let sub = substitute(line, '/\*\|\*/\|{{{\d\=', '', 'g')
    :  return v:folddashes . sub
    :endfunction

计算 'foldtext' 是在 |sandbox| 里完成的。所要显示的内容在当前窗口出现。错误被
忽略。

默认值是 |foldtext()|。对于大多数类型的折叠它可以返回有效的文字。如果你不喜欢
它，你可以自己指定 'foldtext' 。它可以使用以下这些 Vim 变量：
	v:foldstart	在折叠里的第一行
	v:foldend	在折叠里的最后一行
	v:folddashes	一个含有逗号的字符串用来表示折叠级别
	v:foldlevel	折叠级别

在结果中，TAB 被替换为空格，且不可打印的字符被替换为可打印的字符。

结果行被截去以适合窗口的宽度，他决不会被换行。
当在文字后有空余时，用 'fillchars' 来填充。

注意：对那些 ":set" 命令作特殊处理的字符在其前面需加上反斜杠，如：空格，反斜杠
和双引号。 |option-backslash|


折 叠 栏						*fold-foldcolumn*

'foldcolumn'是个数字，它设定了在窗口的边上表示折叠的栏的宽度。当为0时，没有折
叠栏。一个普通值是4或5。最小可用的值是2，最大是12。

一个打开的折叠由一栏，顶端是 '-' 其下方是 '|'，来表示。这栏在折叠结束的地方结
束。当折叠牵套时，牵套的折叠对其被包含的折叠右移一字符而成。

一个关闭的折叠由 '+' 表示。

当折叠栏太窄而不能显示所有折叠时，显示一数字来表示牵套的级别。

在折叠栏点击鼠标，可以打开和关闭折叠：
- 点击 '+' 打开在这行关闭的折叠
- 在任何其他非空字符上点击，来关闭在这行上的折叠


其 他 选 项

'foldenable'  'fen':	当没有置起时，打开所有折叠。
'foldexpr'    'fde':	用于 "expr" 折叠的表达式。
'foldignore'  'fdi':	用于 "indent" 折叠的字符。
'foldmarker'  'fmr':	用于 "marker" 折叠的标记。
'foldmethod'  'fdm':	当前折叠方式的名称。
'foldminlines' 'fml':	一个折叠的最小显示行数。
'foldnestmax' 'fdn':	用于"indent" 和 "syntax" 折叠的最大牵套数。
'foldopen'    'fdo':	用哪一种命令来打开关闭的折叠。
'foldclose'   'fcl':	当光标不在折叠上时关闭折叠。

==============================================================================
4. 折叠表现					*fold-behavior*

当上下移动和滚动时，光标将移至连续折叠的行的第一行。当光标已在被折叠的行上时，
它移动到下一个没有被折叠的行上，或下一个关闭的折叠。

当光标在被折叠的行上时，光标总是显示在第一栏里。光标是应在其实际位置被显示，但
因为被折叠，它无法在那里显示。

移动命令处理连续被折叠的行就象处理空行一样。如， "w" 命令在第一栏停一次。

在插入模式下，光标所在的行不会被折叠。这让你看见你键入的内容。

当使用操作符时，一个关闭的行被作为整体处理。所以 "dl" 在光标下删除了整个关闭的
折叠。

对 Ex 命令的执行范围总是从折叠的第一行到折叠的最后一行。所以，命令： >
	:s/foo/bar/g
当光标在关闭的折叠上时，它将在整个折叠里用 "bar" 替换 "foo" 。
对 |:folddoopen| 和 |:folddoclosed| 不会产生这种情况。

当在编辑一个刚才编辑过的缓冲时，最后被使用过的折叠设置被再次调用。对手工的定义
折叠，它们被恢复。对所有的折叠方式，手工打开和关闭的折叠被恢复。如果这个缓冲曾
经在这个窗口里被编辑，过去用的被恢复。否则，来自过去编辑窗口的值被使用。

==============================================================================
 vim:tw=78:ts=8:ft=help:norl:enc=euc-cn:
